{"version":3,"file":"extension.js","mappings":"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","sources":["../.././src/web/FileSystemWrapper.ts","../.././src/web/FunctionGraphView.ts","../.././src/web/core/cSharpFunctionProjectParser.ts","../.././src/web/core/fSharpFunctionProjectParser.ts","../.././src/web/core/fileSystemWrapperBase.ts","../.././src/web/core/functionProjectCodeParser.ts","../.././src/web/core/functionProjectParser.ts","../.././src/web/core/functionProjectParserBase.ts","../.././src/web/core/functionProjectScriptParser.ts","../.././src/web/core/javaFunctionProjectParser.ts","../.././src/web/core/powershellFunctionProjectParser.ts","../.././src/web/core/pythonV2FunctionProjectParser.ts","../.././src/web/core/traverseFunctionProjectUtils.ts","../../external commonjs \"vscode\"","../../webpack/bootstrap","../.././src/web/extension.ts"],"sourcesContent":["import * as vscode from 'vscode';\r\n\r\nimport { FileSystemWrapperBase } from './core/fileSystemWrapperBase';\r\n\r\nexport class FileSystemWrapper extends FileSystemWrapperBase {\r\n\r\n\tpublic joinPath(path1: string, path2: string): string {\r\n\r\n\t\treturn vscode.Uri.joinPath(vscode.Uri.parse(path1), path2).toString();\r\n\t}\r\n\r\n\tpublic dirName(path1: string): string {\r\n\r\n\t\tconst i = path1.lastIndexOf('/');\r\n\r\n\t\tif (i < 0) {\r\n\t\t\tthrow new Error(`Failed to extract parent folder name from path ${path1}. The path does not contain a separator.`);\r\n\t\t}\r\n\r\n\t\treturn path1.substring(0, i);\r\n\t}\r\n\r\n\tpublic async readFile(path: string): Promise<string> {\r\n\r\n\t\tconst uri = vscode.Uri.parse(path);\r\n\r\n\t\tconst bytes = await vscode.workspace.fs.readFile(uri);\r\n\r\n\t\treturn new TextDecoder().decode(bytes);\r\n\t}\r\n\r\n\tpublic async isDirectory(path: string): Promise<boolean> {\r\n\r\n\t\tconst uri = vscode.Uri.parse(path);\r\n\r\n\t\tconst stat = await vscode.workspace.fs.stat(uri);\r\n\r\n\t\treturn stat.type === vscode.FileType.Directory;\r\n\t}\r\n\r\n\tpublic async readDir(path: string): Promise<string[]> {\r\n\r\n\t\tconst uri = vscode.Uri.parse(path);\r\n\r\n\t\tconst files = await vscode.workspace.fs.readDirectory(uri);\r\n\r\n\t\treturn files.map(f => f[0]);\r\n\t}\r\n\r\n\tpublic async pathExists(path: string): Promise<boolean> {\r\n\r\n\t\tconst uri = vscode.Uri.parse(path);\r\n\r\n\t\ttry {\r\n\t\t\t\r\n\t\t\tconst stat = await vscode.workspace.fs.stat(uri);\r\n\r\n\t\t\treturn stat.type === vscode.FileType.File || stat.type === vscode.FileType.Directory;\r\n\r\n\t\t} catch (err) {\r\n\t\t\r\n\t\t\treturn false;\r\n\t\t}\t\t\r\n\t}\r\n}\r\n","import * as vscode from 'vscode';\r\n\r\nimport { FunctionsMap, ProxiesMap } from './core/FunctionsMap';\r\nimport { FunctionProjectParser } from './core/functionProjectParser';\r\nimport { FileSystemWrapper } from './FileSystemWrapper';\r\n\r\nexport type TraversalResult = {\r\n    functions: FunctionsMap;\r\n    proxies: ProxiesMap;\r\n};\r\n\r\n// Represents the function graph view\r\nexport class FunctionGraphView\r\n{\r\n    constructor(private _context: vscode.ExtensionContext,\r\n        private _functionProjectUri: vscode.Uri) {\r\n        \r\n        this._staticsFolder = vscode.Uri.joinPath(this._context.extensionUri, 'HtmlStatics');\r\n\r\n        this._webViewPanel = this.showWebView();\r\n    }\r\n\r\n    // Closes this web view\r\n    cleanup(): void {\r\n\r\n        if (!!this._webViewPanel) {\r\n            this._webViewPanel.dispose();\r\n        }\r\n    }\r\n\r\n    // Path to html statics\r\n    private _staticsFolder: vscode.Uri;\r\n\r\n    // Reference to the already opened WebView with the main page\r\n    private _webViewPanel: vscode.WebviewPanel | null = null;    \r\n\r\n    // Functions and proxies currently shown\r\n    private _traversalResult?: TraversalResult;\r\n\r\n    private static readonly viewType = 'az-func-as-a-graph';\r\n\r\n    // Opens a WebView with function graph page in it\r\n    private showWebView(): vscode.WebviewPanel {\r\n\r\n        const title = `Functions Graph (${this._functionProjectUri.fsPath})`;\r\n\r\n        const panel = vscode.window.createWebviewPanel(\r\n            FunctionGraphView.viewType,\r\n            title,\r\n            vscode.ViewColumn.One,\r\n            {\r\n                retainContextWhenHidden: true,\r\n                enableScripts: true,\r\n                localResourceRoots: [this._staticsFolder]\r\n            }\r\n        );\r\n\r\n        const fileUri = vscode.Uri.joinPath(this._staticsFolder, 'index.html');\r\n\r\n        vscode.workspace.fs.readFile(fileUri).then(htmlBytes => {\r\n\r\n            let html = new TextDecoder().decode(htmlBytes);\r\n\r\n            html = this.fixLinksToStatics(html, this._staticsFolder, panel.webview);\r\n            html = this.embedTheme(html);\r\n    \r\n            panel.webview.html = html;\r\n    \r\n        }, err => {\r\n\r\n            vscode.window.showErrorMessage(`az-func-as-a-graph failed. ${err.message ?? err}`);\r\n        });\r\n\r\n        // handle events from WebView\r\n        panel.webview.onDidReceiveMessage(request => this.handleMessageFromWebView(panel.webview, request), undefined, this._context.subscriptions);\r\n        \r\n        return panel;\r\n    }\r\n\r\n    // Embeds the current color theme\r\n    private embedTheme(html: string): string {\r\n\r\n        if ([2, 3].includes((vscode.window as any).activeColorTheme.kind)) {\r\n            return html.replace('<script>var ClientConfig={}</script>', '<script>var ClientConfig={\\'theme\\':\\'dark\\'}</script>');\r\n        }\r\n        return html;\r\n    }\r\n\r\n    // Does communication between code in WebView and this class\r\n    private handleMessageFromWebView(webView: vscode.Webview, request: any): void {\r\n\r\n        switch (request.kind) {\r\n\r\n            case 'ShowMessage':\r\n\r\n                vscode.window.showInformationMessage(request.data);\r\n                \r\n                return;\r\n\r\n            case 'ShowError':\r\n\r\n                vscode.window.showErrorMessage(`az-func-as-a-graph failed. ${request.data}`);\r\n                \r\n                return;\r\n            \r\n            case 'SaveAs':\r\n\r\n                // Just to be extra sure...\r\n                if (!this.looksLikeSvg(request.data)) {\r\n                    vscode.window.showErrorMessage(`Invalid data format. Save failed.`);\r\n                    return;\r\n                }\r\n                \r\n                // Saving some file to local hard drive\r\n                vscode.window.showSaveDialog({ defaultUri: vscode.Uri.file('func-map.svg'), filters: { 'SVG Images': ['svg'] } }).then(filePath => {\r\n\r\n                    if (!filePath) { \r\n                        return;\r\n                    }\r\n\r\n                    const bytes = new TextEncoder().encode(request.data);\r\n\r\n                    vscode.workspace.fs.writeFile(filePath, bytes).then(() => {\r\n\r\n                        vscode.window.showInformationMessage(`SVG image saved to ${filePath}`);\r\n\r\n                    }, err => {\r\n\r\n                        vscode.window.showErrorMessage(`Failed to save. ${err.message ?? err}`);\r\n                    });\r\n\r\n                });\r\n                return;\r\n            \r\n            case 'SaveFunctionGraphAsJson':\r\n\r\n                if (!this._traversalResult) {\r\n                    return;\r\n                }\r\n                \r\n                // Saving some file to local hard drive\r\n                vscode.window.showSaveDialog({ defaultUri: vscode.Uri.file('func-map.json'), filters: { 'JSON': ['json'] } }).then(filePath => {\r\n\r\n                    if (!filePath) { \r\n                        return;\r\n                    }\r\n\r\n                    const bytes = new TextEncoder().encode(JSON.stringify(this._traversalResult, null, 3));\r\n\r\n                    vscode.workspace.fs.writeFile(filePath, bytes).then(() => {\r\n\r\n                        vscode.window.showInformationMessage(`Diagram JSON saved to ${filePath}`);\r\n\r\n                    }, err => {\r\n\r\n                        vscode.window.showErrorMessage(`Failed to save. ${err.message ?? err}`);\r\n                    });\r\n\r\n                });\r\n                return;\r\n            \r\n            case 'GotoFunctionCode':\r\n\r\n                if (!this._traversalResult) {\r\n                    return;\r\n                }\r\n\r\n                const functionName = request.data;\r\n                var functionOrProxy: any = null;\r\n\r\n                if (functionName.startsWith('proxy.')) {\r\n            \r\n                    functionOrProxy = this._traversalResult.proxies[functionName.substr(6)];\r\n    \r\n                } else {\r\n    \r\n                    functionOrProxy = this._traversalResult.functions[functionName];\r\n                }\r\n    \r\n                vscode.window.showTextDocument(vscode.Uri.parse(functionOrProxy.filePath)).then(ed => {\r\n\r\n                    const pos = ed.document.positionAt(!!functionOrProxy.pos ? functionOrProxy.pos : 0);\r\n\r\n                    ed.selection = new vscode.Selection(pos, pos);\r\n                    ed.revealRange(new vscode.Range(pos, pos));\r\n\r\n                });\r\n\r\n                return;\r\n            \r\n            case 'Refresh':\r\n\r\n                FunctionProjectParser.parseFunctions(this._functionProjectUri.toString(), new FileSystemWrapper(), console.log).then(res => {\r\n\r\n                    console.log(`>>>>>> ${this._functionProjectUri}: ${Object.keys(res.functions).length} functions`);\r\n\r\n                    this._traversalResult = res;\r\n                    webView.postMessage(this._traversalResult);\r\n        \r\n                }).catch(err => {\r\n\r\n                    this._traversalResult = undefined;\r\n                    webView.postMessage(undefined);\r\n                    \r\n                    vscode.window.showErrorMessage(`az-func-as-a-graph failed. ${err.message ?? err}`);\r\n                });\r\n                    \r\n                return;\r\n        }\r\n    }\r\n\r\n    private fixLinksToStatics(originalHtml: string, staticsFolder: vscode.Uri, webView: vscode.Webview): string {\r\n\r\n        var resultHtml: string = originalHtml;\r\n    \r\n        const regex = / (href|src)=\"\\/([0-9a-z.\\/]+)\"/ig;\r\n        var match: RegExpExecArray | null;\r\n        while (match = regex.exec(originalHtml)) {\r\n    \r\n            const relativePath = match[2];\r\n            const localPath = vscode.Uri.joinPath(staticsFolder, relativePath)\r\n            const newPath = webView.asWebviewUri(localPath).toString();\r\n    \r\n            resultHtml = resultHtml.replace(`/${relativePath}`, newPath);\r\n        }\r\n    \r\n        return resultHtml;\r\n    }\r\n\r\n    // Validates incoming SVG, just to be extra sure...\r\n    private looksLikeSvg(data: string): boolean {\r\n        return data.startsWith('<svg') && data.endsWith('</svg>') && !data.toLowerCase().includes('<script');\r\n    }\r\n}","import { FunctionsMap } from \"./FunctionsMap\";\r\nimport { getCodeInBrackets, posToLineNr, removeNamespace } from \"./traverseFunctionProjectUtils\";\r\n\r\nimport { FunctionProjectCodeParser } from \"./functionProjectCodeParser\";\r\n\r\nexport class CSharpFunctionProjectParser extends FunctionProjectCodeParser {\r\n\r\n    protected async getFunctionsAndTheirCodesAsync(functionNames: string[], hostJsonFolder: string): Promise<{ name: string; code: string; filePath: string; pos: number; lineNr: number; }[]> {\r\n        \r\n        const promises = functionNames.map(async name => {\r\n\r\n            const match = await this._fileSystemWrapper.findFileRecursivelyAsync(hostJsonFolder, '.+\\\\.cs$', true, this.getFunctionStartRegex(name));\r\n            \r\n            if (!match) {\r\n                return undefined;\r\n            }\r\n    \r\n            const pos = !match.pos ? 0 : match.pos;\r\n            const lineNr = posToLineNr(match.code, pos);\r\n            const code = getCodeInBrackets(match.code!, match.pos! + match.length!, '{', '}', '\\n').code;\r\n    \r\n            return { name, code, filePath: match.filePath, pos, lineNr };\r\n        });\r\n    \r\n        return (await Promise.all(promises)).filter(f => !!f) as any;\r\n    }\r\n\r\n    protected async traverseProjectCode(projectFolder: string): Promise<FunctionsMap> {\r\n\r\n        const result: any = {};\r\n\r\n        const fileNameRegex = new RegExp('.+\\\\.cs$', 'i');\r\n\r\n        for await (const func of this._fileSystemWrapper.findFunctionsRecursivelyAsync(projectFolder, fileNameRegex, this.getFunctionAttributeRegex())) {\r\n            \r\n            const bindings = this.tryExtractBindings(func.declarationCode);\r\n       \r\n            if ( !(\r\n                bindings.some(b => b.type === 'orchestrationTrigger') ||\r\n                bindings.some(b => b.type === 'entityTrigger') ||\r\n                bindings.some(b => b.type === 'activityTrigger')\r\n            )) {\r\n                \r\n                // Also trying to extract multiple output bindings\r\n                bindings.push(...await this.extractOutputBindings(projectFolder, func.declarationCode, fileNameRegex));\r\n            }\r\n    \r\n            result[func.functionName] = {\r\n    \r\n                filePath: func.filePath,\r\n                pos: func.pos,\r\n                lineNr: func.lineNr,\r\n    \r\n                bindings: [...bindings]\r\n            };\r\n        }\r\n    \r\n        return result;\r\n    }\r\n\r\n    private async extractOutputBindings(projectFolder: string, functionCode: string, fileNameRegex: RegExp): Promise<{ type: string, direction: string }[]> {\r\n    \r\n        const returnTypeMatch = this.functionReturnTypeRegex.exec(functionCode);\r\n        if (!returnTypeMatch) {\r\n            return [];\r\n        }\r\n    \r\n        const returnTypeName = removeNamespace(returnTypeMatch[3]);\r\n        if (!returnTypeName) {\r\n            return [];\r\n        }\r\n    \r\n        const returnTypeDefinition = await this._fileSystemWrapper.findFileRecursivelyAsync(projectFolder, fileNameRegex, true, this.getClassDefinitionRegex(returnTypeName));\r\n        if (!returnTypeDefinition) {\r\n            return [];\r\n        }\r\n    \r\n        const classBody = getCodeInBrackets(returnTypeDefinition.code!, (returnTypeDefinition.pos ?? 0) + (returnTypeDefinition.length ?? 0), '{', '}');\r\n        if (!classBody.code) {\r\n            return [];\r\n        }\r\n    \r\n        return this.tryExtractBindings(classBody.code);\r\n    }\r\n}\r\n","import { FunctionsMap } from \"./FunctionsMap\";\r\nimport { getCodeInBrackets, posToLineNr } from \"./traverseFunctionProjectUtils\";\r\n\r\nimport { RegExAndPos } from \"./fileSystemWrapperBase\";\r\nimport { FunctionProjectCodeParser } from \"./functionProjectCodeParser\";\r\n\r\nexport class FSharpFunctionProjectParser extends FunctionProjectCodeParser {\r\n\r\n    protected async getFunctionsAndTheirCodesAsync(functionNames: string[], hostJsonFolder: string): Promise<{ name: string; code: string; filePath: string; pos: number; lineNr: number; }[]> {\r\n\r\n        const promises = functionNames.map(async name => {\r\n\r\n            const match = await this._fileSystemWrapper.findFileRecursivelyAsync(hostJsonFolder, '.+\\\\.fs$', true, this.getFunctionStartRegex(name));\r\n            \r\n            if (!match) {\r\n                return undefined;\r\n            }\r\n\r\n            const code = getCodeInBrackets(match.code!, match.pos! + match.length!, '{', '}', '\\n').code;\r\n            const pos = !match.pos ? 0 : match.pos;\r\n            const lineNr = posToLineNr(match.code, pos);\r\n\r\n            return { name, code, filePath: match.filePath, pos, lineNr };\r\n        });\r\n\r\n        return (await Promise.all(promises)).filter(f => !!f) as any;\r\n    }\r\n\r\n    protected async traverseProjectCode(projectFolder: string): Promise<FunctionsMap> {\r\n\r\n        const result: any = {};\r\n\r\n        for await (const func of this._fileSystemWrapper.findFunctionsRecursivelyAsync(projectFolder, new RegExp('.+\\\\.fs$', 'i'), this.getFunctionAttributeRegex())) {\r\n            \r\n            const bindings = this.tryExtractBindings(func.declarationCode);\r\n    \r\n            result[func.functionName] = {\r\n\r\n                filePath: func.filePath,\r\n                pos: func.pos,\r\n                lineNr: func.lineNr,\r\n\r\n                bindings: [...bindings]\r\n            };\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    protected getFunctionAttributeRegex(): RegExAndPos {\r\n        return {\r\n            regex: new RegExp(`\\\\[<\\\\s*Function(Name)?\\\\s*\\\\(([\"\\\\w\\\\s\\\\.\\\\(\\\\)-]+)\\\\)`, 'g'),\r\n            pos: 2\r\n        };\r\n    }\r\n}","import { cleanupFunctionName, getCodeInBrackets, posToLineNr } from './traverseFunctionProjectUtils';\r\nimport { FunctionsMap, ProxiesMap } from './FunctionsMap';\r\n\r\nconst ExcludedFolders = ['node_modules', 'target', 'bin', 'obj', '.vs', '.vscode', '.env', '.python_packages', '.git', '.github'];\r\n\r\nexport type RegExAndPos = { regex: RegExp, pos: number };\r\n\r\n// Base class for implementing filesystem wrappers\r\nexport abstract class FileSystemWrapperBase {\r\n\r\n    public abstract dirName(path1: string): string;\r\n\r\n    public abstract joinPath(path1: string, path2: string): string;\r\n\r\n    public abstract readFile(path: string): Promise<string>;\r\n\r\n    public abstract isDirectory(path: string): Promise<boolean>;\r\n\r\n    public abstract readDir(path: string): Promise<string[]>;\r\n\r\n    public abstract pathExists(path: string): Promise<boolean>;\r\n\r\n    async readFunctionsJson(hostJsonFolder: string, log: (s: any) => void): Promise<FunctionsMap> {\r\n\r\n        let functions: FunctionsMap = {};\r\n    \r\n            // Reading function.json files, in parallel\r\n            const promises = (await this.readDir(hostJsonFolder)).map(async functionName => {\r\n    \r\n                const fullPath = this.joinPath(hostJsonFolder, functionName);\r\n                const functionJsonFilePath = this.joinPath(fullPath, 'function.json');\r\n    \r\n                const isDirectory = await this.isDirectory(fullPath);\r\n                const functionJsonExists = await this.pathExists(functionJsonFilePath);\r\n    \r\n                if (isDirectory && functionJsonExists) {\r\n    \r\n                    try {\r\n                        const functionJsonString = await this.readFile(functionJsonFilePath);\r\n                        const functionJson = JSON.parse(functionJsonString);\r\n    \r\n                        functions[functionName] = { bindings: functionJson.bindings, isCalledBy: [], isSignalledBy: [] };\r\n    \r\n                    } catch (err) {\r\n                        log(`>>> Failed to parse ${functionJsonFilePath}: ${err}`);\r\n                    }\r\n                }\r\n            });\r\n            await Promise.all(promises);\r\n        \r\n        return functions;\r\n    }\r\n\r\n    async readProxiesJson(projectFolder: string, log: (s: any) => void): Promise<ProxiesMap> {\r\n\r\n        const proxiesJsonPath = this.joinPath(projectFolder, 'proxies.json');\r\n        if (!(await this.pathExists(proxiesJsonPath))) {\r\n            return {};\r\n        }\r\n        \r\n        const proxiesJsonString = await this.readFile(proxiesJsonPath);\r\n        try {\r\n    \r\n            const proxies = JSON.parse(proxiesJsonString).proxies as ProxiesMap;\r\n            if (!proxies) {\r\n                return {};\r\n            }\r\n    \r\n            var notAddedToCsProjFile = false;\r\n            if (await this.isCSharpProjectAsync(projectFolder)) {\r\n    \r\n                // Also checking that proxies.json is added to .csproj file\r\n    \r\n                const csProjFile = await this.findFileRecursivelyAsync(projectFolder, '.+\\\\.csproj$', true);\r\n                const proxiesJsonEntryRegex = new RegExp(`\\\\s*=\\\\s*\"proxies.json\"\\\\s*>`);\r\n    \r\n                if (!!csProjFile && csProjFile.code && (!proxiesJsonEntryRegex.exec(csProjFile.code))) {\r\n                    \r\n                    notAddedToCsProjFile = true;\r\n                }            \r\n            }\r\n    \r\n            // Also adding filePath and lineNr\r\n            for (var proxyName in proxies) {\r\n    \r\n                const proxy = proxies[proxyName];\r\n                proxy.filePath = proxiesJsonPath;\r\n                if (notAddedToCsProjFile) {\r\n                    proxy.warningNotAddedToCsProjFile = true;\r\n                }\r\n    \r\n                const proxyNameRegex = new RegExp(`\"${proxyName}\"\\\\s*:`);\r\n                const match = proxyNameRegex.exec(proxiesJsonString);\r\n                if (!!match) {\r\n                    \r\n                    proxy.pos = match.index;\r\n                    proxy.lineNr = posToLineNr(proxiesJsonString, proxy.pos);\r\n                }\r\n            }\r\n    \r\n            return proxies;\r\n    \r\n        } catch(err) {\r\n    \r\n            log(`>>> Failed to parse ${proxiesJsonPath}: ${err}`);\r\n            return {};\r\n        }\r\n    }\r\n\r\n    async isCSharpProjectAsync(projectFolder: string): Promise<boolean> {\r\n        return (await this.readDir(projectFolder)).some(fn => {\r\n            fn = fn.toLowerCase();\r\n            return (fn.endsWith('.csproj') && fn !== 'extensions.csproj');\r\n        });\r\n    }\r\n\r\n    async isFSharpProjectAsync(projectFolder: string): Promise<boolean> {\r\n        return (await this.readDir(projectFolder)).some(fn => {\r\n            fn = fn.toLowerCase();\r\n            return fn.endsWith('.fsproj');\r\n        });\r\n    }\r\n\r\n    async isJavaProjectAsync(projectFolder: string): Promise<boolean> {\r\n\r\n        const javaFileMatch = await this.findFileRecursivelyAsync(projectFolder, `.+\\\\.java$`, false);\r\n        return !!javaFileMatch;\r\n    }\r\n\r\n    async isPowershellProjectAsync(projectFolder: string): Promise<boolean> {\r\n\r\n        const firstFunctionJsonFile = await this.findFileRecursivelyAsync(projectFolder, `function.json`, false);\r\n\r\n        if (!firstFunctionJsonFile || !firstFunctionJsonFile.filePath) {\r\n            return false;\r\n        }\r\n\r\n        const psFileMatch = await this.findFileRecursivelyAsync(this.dirName(firstFunctionJsonFile.filePath), `.+\\\\.ps1$`, false);\r\n\r\n        return !!psFileMatch;\r\n    }\r\n\r\n    async isPythonV2ProjectAsync(projectFolder: string): Promise<boolean> {\r\n\r\n        const pyFileMatch = await this.findFileRecursivelyAsync(projectFolder, `.+\\\\.py$`, false);\r\n        const functionJsonFileMatch = await this.findFileRecursivelyAsync(projectFolder, `function.json`, false);\r\n\r\n        return !!pyFileMatch && !functionJsonFileMatch;\r\n    }\r\n\r\n    async findFileRecursivelyAsync(folder: string, fileName: string | RegExp, returnFileContents: boolean, pattern?: RegExp)\r\n        : Promise<{ filePath: string, code?: string, pos?: number, length?: number } | undefined> {\r\n\r\n        const fileNameRegex = typeof fileName === 'string' ? new RegExp(fileName, 'i') : fileName;\r\n\r\n        const subFolders: string[] = [];\r\n\r\n        for (const name of await this.readDir(folder)) {\r\n\r\n            const fullPath = this.joinPath(folder, name);\r\n            const isDirectory = await this.isDirectory(fullPath);\r\n\r\n            if (!!isDirectory) {\r\n\r\n                if (!ExcludedFolders.includes(name.toLowerCase())) {\r\n\r\n                    subFolders.push(fullPath);\r\n                }\r\n\r\n            } else if (!!fileNameRegex.exec(name)) {\r\n\r\n                if (!pattern) {\r\n                    return {\r\n                        filePath: fullPath,\r\n                        code: returnFileContents ? (await this.readFile(fullPath)) : undefined\r\n                    };\r\n                }\r\n\r\n                const code = await this.readFile(fullPath);\r\n                const match = pattern.exec(code);\r\n\r\n                if (!!match) {\r\n                    return {\r\n                        filePath: fullPath,\r\n                        code: returnFileContents ? code : undefined,\r\n                        pos: match.index,\r\n                        length: match[0].length\r\n                    };\r\n                }\r\n            }\r\n        }\r\n\r\n        // Now recursively trying subfolders. Doing this _after_ checking the current folder.\r\n        for (const subFolder of subFolders) {\r\n            \r\n            const result = await this.findFileRecursivelyAsync(subFolder, fileNameRegex, returnFileContents, pattern);\r\n            if (!!result) {\r\n                return result;\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    async * findFilesRecursivelyAsync(folder: string, fileNameRegex: RegExp): AsyncGenerator<any> {\r\n\r\n        for (const name of await this.readDir(folder)) {\r\n    \r\n            var fullPath = this.joinPath(folder, name);\r\n            const isDirectory = await this.isDirectory(fullPath);\r\n    \r\n            if (!!isDirectory) {\r\n    \r\n                if (ExcludedFolders.includes(name.toLowerCase())) {\r\n                    continue;\r\n                }\r\n    \r\n                for await (const path of this.findFilesRecursivelyAsync(fullPath, fileNameRegex)) {\r\n    \r\n                    yield path;\r\n                }\r\n    \r\n            } else if (!!fileNameRegex.exec(name)) {\r\n    \r\n                yield fullPath;\r\n            }\r\n        }\r\n    }\r\n\r\n    async * findFunctionsRecursivelyAsync(folder: string, fileNameRegex: RegExp, functionAttributeRegex: RegExAndPos): AsyncGenerator<any> {\r\n\r\n        for await (const fullPath of this.findFilesRecursivelyAsync(folder, fileNameRegex)) {\r\n\r\n            const code = await this.readFile(fullPath);\r\n\r\n            var match: RegExpExecArray | null;\r\n            while (!!(match = functionAttributeRegex.regex.exec(code))) {\r\n\r\n                let functionName = cleanupFunctionName(match[functionAttributeRegex.pos]);\r\n\r\n                const functionAttributeEndPos = match.index + match[0].length;\r\n\r\n                const body = getCodeInBrackets(code, functionAttributeEndPos, '{', '}', '\\n');\r\n\r\n                if (body.openBracketPos >= 0 && !!body.code) {\r\n\r\n                    yield {\r\n                        functionName,\r\n                        filePath: fullPath,\r\n                        pos: match.index,\r\n                        lineNr: posToLineNr(code, match.index),\r\n                        declarationCode: body.code.substring(0, body.openBracketPos),\r\n                        bodyCode: body.code.substring(body.openBracketPos)\r\n                    };\r\n\r\n                } else {\r\n\r\n                    // Returning the rest of the file\r\n\r\n                    yield {\r\n                        functionName,\r\n                        filePath: fullPath,\r\n                        pos: match.index,\r\n                        lineNr: posToLineNr(code, match.index),\r\n\r\n                        declarationCode: code.substring(functionAttributeEndPos),\r\n                        bodyCode: code.substring(functionAttributeEndPos)\r\n                    };\r\n\r\n                    break;\r\n                }\r\n            }        \r\n        }\r\n    }\r\n}","import { FunctionsMap } from \"./FunctionsMap\";\r\n\r\nimport { FunctionProjectParserBase } from './functionProjectParserBase';\r\nimport { RegExAndPos } from \"./fileSystemWrapperBase\";\r\n\r\nexport abstract class FunctionProjectCodeParser extends FunctionProjectParserBase {\r\n\r\n    public async traverseFunctions(projectFolder: string): Promise<FunctionsMap>{\r\n        \r\n        let functions: FunctionsMap;\r\n\r\n        functions = await this.traverseProjectCode(projectFolder);\r\n\r\n        // Now enriching it with more info extracted from code\r\n        functions = await this.mapOrchestratorsAndActivitiesAsync(functions, projectFolder);\r\n\r\n        return functions;\r\n    }\r\n\r\n    protected abstract traverseProjectCode(projectFolder: string): Promise<FunctionsMap>;\r\n\r\n    protected getFunctionStartRegex(funcName: string): RegExp {\r\n        return new RegExp(`Function(Name)?(Attribute)?\\\\s*\\\\(\\\\s*(nameof\\\\s*\\\\(\\\\s*|[\"'\\`]|[\\\\w\\\\s\\\\.]+\\\\.\\\\s*)${funcName}\\\\s*[\"'\\`\\\\)]{1}`)\r\n    }\r\n\r\n    protected getFunctionAttributeRegex(): RegExAndPos {\r\n        return {\r\n            regex: new RegExp(`\\\\[\\\\s*Function(Name)?(Attribute)?\\\\s*\\\\(([\"\\\\w\\\\s\\\\.\\\\(\\\\)-]+)\\\\)\\\\s*\\\\]`, 'g'),\r\n            pos: 3\r\n        };\r\n    }\r\n}\r\n","import { TraverseFunctionResult } from \"./FunctionsMap\";\r\nimport { FileSystemWrapperBase } from './fileSystemWrapperBase';\r\n\r\nimport { FunctionProjectParserBase } from './functionProjectParserBase';\r\nimport { FunctionProjectScriptParser } from './functionProjectScriptParser';\r\nimport { CSharpFunctionProjectParser } from './cSharpFunctionProjectParser';\r\nimport { FSharpFunctionProjectParser } from './fSharpFunctionProjectParser';\r\nimport { JavaFunctionProjectParser } from './javaFunctionProjectParser';\r\nimport { PowershellFunctionProjectParser } from './powershellFunctionProjectParser';\r\nimport { PythonV2FunctionProjectParser } from './pythonV2FunctionProjectParser';\r\n\r\n// Parses Azure Functions projects to produce Functions map (list of all Functions, their bindings and connections to other Functions)\r\nexport abstract class FunctionProjectParser {\r\n\r\n    // Collects all function.json files in a Functions project. Also tries to supplement them with bindings\r\n    // extracted from code (if the project is .Net or Java). Also parses and organizes orchestrators/activities \r\n    // (if the project uses Durable Functions)\r\n    public static async parseFunctions(projectFolder: string, fileSystemWrapper: FileSystemWrapperBase, log: (s: any) => void)\r\n        : Promise<TraverseFunctionResult> {\r\n                \r\n        const hostJsonMatch = await fileSystemWrapper.findFileRecursivelyAsync(projectFolder, 'host.json', false);\r\n        if (!hostJsonMatch) {\r\n            throw new Error('host.json file not found under the provided project path');\r\n        }\r\n\r\n        log(`>>> Found host.json at ${hostJsonMatch.filePath}`);\r\n\r\n        const hostJsonFolder = fileSystemWrapper.dirName(hostJsonMatch.filePath);\r\n        \r\n        let parser: FunctionProjectParserBase;\r\n\r\n        if (await fileSystemWrapper.isCSharpProjectAsync(hostJsonFolder)) {\r\n            parser = new CSharpFunctionProjectParser(fileSystemWrapper, log);\r\n        } else if (await fileSystemWrapper.isFSharpProjectAsync(hostJsonFolder)) {\r\n            parser = new FSharpFunctionProjectParser(fileSystemWrapper, log);\r\n        } else if (await fileSystemWrapper.isJavaProjectAsync(hostJsonFolder)) {\r\n            parser = new JavaFunctionProjectParser(fileSystemWrapper, log);\r\n        } else if (await fileSystemWrapper.isPowershellProjectAsync(hostJsonFolder)) {\r\n            parser = new PowershellFunctionProjectParser(fileSystemWrapper, log);\r\n        } else if (await fileSystemWrapper.isPythonV2ProjectAsync(hostJsonFolder)) {\r\n            parser = new PythonV2FunctionProjectParser(fileSystemWrapper, log);\r\n        } else {\r\n            parser = new FunctionProjectScriptParser(fileSystemWrapper, log);\r\n\r\n            // For script-based functions use host.json's folder as the root\r\n            projectFolder = hostJsonFolder;\r\n        }\r\n\r\n        const functions = await parser.traverseFunctions(projectFolder);\r\n        \r\n        // Also reading proxies\r\n        const proxies = await fileSystemWrapper.readProxiesJson(projectFolder, log);\r\n\r\n        return { functions, proxies, projectFolder };\r\n    }\r\n}\r\n","import { FunctionsMap } from \"./FunctionsMap\";\r\nimport { FileSystemWrapperBase, RegExAndPos } from './fileSystemWrapperBase';\r\nimport { getCodeInBrackets } from \"./traverseFunctionProjectUtils\";\r\n\r\n// Parses Azure Functions projects to produce Functions map (list of all Functions, their bindings and connections to other Functions)\r\nexport abstract class FunctionProjectParserBase {\r\n\r\n    public constructor(protected _fileSystemWrapper: FileSystemWrapperBase, protected _log: (s: any) => void) {\r\n        \r\n    }\r\n\r\n    public abstract traverseFunctions(projectFolder: string) : Promise<FunctionsMap>;\r\n\r\n    protected abstract getFunctionsAndTheirCodesAsync(functionNames: string[], hostJsonFolder: string)\r\n        : Promise<{ name: string, code: string, filePath: string, pos: number, lineNr: number }[]>    \r\n\r\n    // Tries to match orchestrations and their activities by parsing source code\r\n    protected async mapOrchestratorsAndActivitiesAsync(functions: FunctionsMap, projectFolder: string): Promise<FunctionsMap> {\r\n\r\n        const functionNames = Object.keys(functions);\r\n        \r\n        const orchestratorNames = functionNames.filter(name => functions[name].bindings.some((b: any) => b.type === 'orchestrationTrigger'));\r\n        const orchestrators = await this.getFunctionsAndTheirCodesAsync(orchestratorNames, projectFolder);\r\n\r\n        const activityNames = Object.keys(functions).filter(name => functions[name].bindings.some((b: any) => b.type === 'activityTrigger'));\r\n        const activities = await this.getFunctionsAndTheirCodesAsync(activityNames, projectFolder);\r\n\r\n        const entityNames = functionNames.filter(name => functions[name].bindings.some((b: any) => b.type === 'entityTrigger'));\r\n        const entities = await this.getFunctionsAndTheirCodesAsync(entityNames, projectFolder);\r\n\r\n        const otherFunctionNames = functionNames.filter(name => !functions[name].bindings.some((b: any) => ['orchestrationTrigger', 'activityTrigger', 'entityTrigger'].includes(b.type)));\r\n        const otherFunctions = await this.getFunctionsAndTheirCodesAsync(otherFunctionNames, projectFolder);\r\n\r\n        for (const orch of orchestrators) {\r\n\r\n            // Trying to match this orchestrator with its calling function\r\n            const regex = this.getStartNewOrchestrationRegex(orch.name);\r\n            for (const func of otherFunctions) {\r\n\r\n                // If this function seems to be calling that orchestrator\r\n                if (!!regex.exec(func.code)) {\r\n\r\n                    functions[orch.name].isCalledBy = functions[orch.name].isCalledBy ?? [];\r\n                    functions[orch.name].isCalledBy.push(func.name);\r\n                }\r\n            }\r\n\r\n            // Matching suborchestrators\r\n            for (const subOrch of orchestrators) {\r\n                if (orch.name === subOrch.name) {\r\n                    continue;\r\n                }\r\n\r\n                // If this orchestrator seems to be calling that suborchestrator\r\n                const regex = this.getCallSubOrchestratorRegex(subOrch.name);\r\n                if (!!regex.exec(orch.code)) {\r\n\r\n                    // Mapping that suborchestrator to this orchestrator\r\n                    functions[subOrch.name].isCalledBy = functions[subOrch.name].isCalledBy ?? [];\r\n                    functions[subOrch.name].isCalledBy.push(orch.name);\r\n                }\r\n            }\r\n\r\n            // Mapping activities to orchestrators\r\n            this.mapActivitiesToOrchestrator(functions, orch, activityNames);\r\n\r\n            // Checking whether orchestrator calls itself\r\n            if (!!this.getContinueAsNewRegex().exec(orch.code)) {\r\n                functions[orch.name].isCalledByItself = true;\r\n            }\r\n\r\n            // Trying to map event producers with their consumers\r\n            const eventNames = this.getEventNames(orch.code);\r\n            for (const eventName of eventNames) {\r\n                \r\n                const regex = this.getRaiseEventRegex(eventName);\r\n                for (const func of otherFunctions) {\r\n\r\n                    // If this function seems to be sending that event\r\n                    if (!!regex.exec(func.code)) {\r\n                        functions[orch.name].isSignalledBy = functions[orch.name].isSignalledBy ?? [];\r\n                        functions[orch.name].isSignalledBy.push({ name: func.name, signalName: eventName });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const entity of entities) {\r\n\r\n            // Trying to match this entity with its calling function\r\n            for (const func of otherFunctions) {\r\n\r\n                // If this function seems to be calling that entity\r\n                const regex = this.getSignalEntityRegex(entity.name);\r\n                if (!!regex.exec(func.code)) {\r\n                    functions[entity.name].isCalledBy = functions[entity.name].isCalledBy ?? [];\r\n                    functions[entity.name].isCalledBy.push(func.name);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Also adding file paths and code positions\r\n        for (const func of otherFunctions.concat(orchestrators).concat(activities).concat(entities)) {\r\n            functions[func.name].filePath = func.filePath;\r\n            functions[func.name].pos = func.pos;\r\n            functions[func.name].lineNr = func.lineNr;\r\n        }\r\n\r\n        return functions;\r\n    }\r\n\r\n    // Tries to extract event names that this orchestrator is awaiting\r\n    protected getEventNames(orchestratorCode: string): string[] {\r\n\r\n        const result = [];\r\n\r\n        const regex = this.getWaitForExternalEventRegex();\r\n        var match: RegExpExecArray | null;\r\n        while (!!(match = regex.regex.exec(orchestratorCode))) {\r\n            result.push(match[regex.pos]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // Tries to match orchestrator with its activities\r\n    protected mapActivitiesToOrchestrator(functions: FunctionsMap, orch: {name: string, code: string}, activityNames: string[]): void {\r\n\r\n        for (const activityName of activityNames) {\r\n\r\n            // If this orchestrator seems to be calling this activity\r\n            const regex = this.getCallActivityRegex(activityName);\r\n            if (!!regex.exec(orch.code)) {\r\n\r\n                // Then mapping this activity to this orchestrator\r\n                functions[activityName].isCalledBy = functions[activityName].isCalledBy ?? [];\r\n                functions[activityName].isCalledBy.push(orch.name);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Extracts additional bindings info from C#/F# source code\r\n    protected tryExtractBindings(funcCode: string): {type: string, direction: string}[] {\r\n\r\n        const result: {type: string, direction: string}[] = [];\r\n\r\n        if (!funcCode) {\r\n            return result;\r\n        }\r\n\r\n        const regex = this.getBindingAttributeRegex();\r\n        let match: RegExpExecArray | null;\r\n        while (!!(match = regex.regex.exec(funcCode))) {\r\n\r\n            const isReturn = match[regex.pos - 1] === 'return:';\r\n\r\n            let attributeName = match[regex.pos];\r\n            if (attributeName.endsWith(`Attribute`)) {\r\n                attributeName = attributeName.substring(0, attributeName.length - `Attribute`.length);\r\n            }\r\n\r\n            const attributeCodeStartIndex = match.index + match[0].length;\r\n            const attributeCode = getCodeInBrackets(funcCode, attributeCodeStartIndex, '(', ')', '').code;\r\n\r\n            this.isOutRegex.lastIndex = attributeCodeStartIndex + attributeCode.length;\r\n            const isOut = !!this.isOutRegex.exec(funcCode);\r\n\r\n            switch (attributeName) {\r\n                case 'read_blob':\r\n                case 'blob_input':\r\n                case 'blob_output':\r\n                case 'BlobInput':\r\n                case 'BlobOutput': \r\n                case 'Blob': {\r\n                    const binding: any = {\r\n                        type: 'blob',\r\n                        direction: attributeName === 'Blob' ? (isReturn || isOut ? 'out' : 'in') : (attributeName.toLowerCase().endsWith('output') ? 'out' : 'in')\r\n                    };\r\n\r\n                    const paramsMatch = this.blobParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.path = paramsMatch[1];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'blob_trigger':\r\n                case 'BlobTrigger': {\r\n                    const binding: any = { type: 'blobTrigger' };\r\n\r\n                    const paramsMatch = this.blobParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.path = paramsMatch[1];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'table_input':\r\n                case 'table_output':\r\n                case 'TableInput':\r\n                case 'TableOutput': \r\n                case 'Table': {\r\n                    const binding: any = {\r\n                        type: 'table',\r\n                        direction: attributeName === 'Table' ? (isReturn || isOut ? 'out' : 'in') : (attributeName.toLowerCase().endsWith('output') ? 'out' : 'in')\r\n                    };\r\n\r\n                    const paramsMatch = this.singleParamRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.tableName = paramsMatch[2];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'CosmosDBInput': \r\n                case 'CosmosDBOutput': \r\n                case 'CosmosDB': {\r\n                    const binding: any = {\r\n                        type: 'cosmosDB',\r\n                        direction: attributeName === 'CosmosDB' ? (isReturn || isOut ? 'out' : 'in') : (attributeName.toLowerCase().endsWith('output') ? 'out' : 'in')\r\n                    };\r\n\r\n                    const paramsMatch = this.cosmosDbParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.databaseName = paramsMatch[1];\r\n                        binding.collectionName = paramsMatch[3];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'cosmos_db_trigger':\r\n                case 'CosmosDBTrigger': {\r\n                    const binding: any = { type: 'cosmosDBTrigger' };\r\n\r\n                    const paramsMatch = this.singleParamRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.databaseName = paramsMatch[2];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'event_grid_output': \r\n                case 'EventGrid': \r\n                case 'EventGridOutput': {\r\n                    const binding: any = { type: 'eventGrid', direction: 'out' };\r\n\r\n                    const paramsMatch = this.eventGridParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.topicEndpointUri = paramsMatch[1];\r\n                        binding.topicKeySetting = paramsMatch[3];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'EventGridTrigger': {\r\n                    const binding: any = { type: 'eventGridTrigger' };\r\n\r\n                    const paramsMatch = this.eventGridParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.topicEndpointUri = paramsMatch[1];\r\n                        binding.topicKeySetting = paramsMatch[3];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'event_hub_output':\r\n                case 'EventHub': \r\n                case 'EventHubOutput': {\r\n                    const binding: any = { type: 'eventHub', direction: 'out' };\r\n\r\n                    const paramsMatch = this.eventHubParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.eventHubName = paramsMatch[1];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'event_hub_message_trigger':\r\n                case 'EventHubTrigger': {\r\n                    const binding: any = { type: 'eventHubTrigger' };\r\n\r\n                    const paramsMatch = this.eventHubParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.eventHubName = paramsMatch[1];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'Kafka': \r\n                case 'KafkaOutput': {\r\n                    const binding: any = { type: 'kafka', direction: 'out' };\r\n\r\n                    const paramsMatch = this.singleParamRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.brokerList = paramsMatch[2];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'KafkaTrigger': {\r\n                    const binding: any = { type: 'kafkaTrigger' };\r\n\r\n                    const paramsMatch = this.singleParamRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.brokerList = paramsMatch[2];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'queue_output':\r\n                case 'Queue': \r\n                case 'QueueOutput': {\r\n                    const binding: any = { type: 'queue', direction: 'out' };\r\n\r\n                    const paramsMatch = this.singleParamRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding['queueName'] = paramsMatch[2];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'queue_trigger':\r\n                case 'QueueTrigger': {\r\n                    const binding: any = { type: 'queueTrigger' };\r\n\r\n                    const paramsMatch = this.singleParamRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding['queueName'] = paramsMatch[2];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'service_bus_queue_output':\r\n                case 'service_bus_topic_output':\r\n                case 'ServiceBus': \r\n                case 'ServiceBusOutput': {\r\n                    const binding: any = { type: 'serviceBus', direction: 'out' };\r\n\r\n                    const paramsMatch = this.singleParamRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding['queueName'] = paramsMatch[2];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'service_bus_queue_trigger':\r\n                case 'service_bus_topic_trigger':\r\n                case 'ServiceBusTrigger': \r\n                case 'ServiceBusQueueTrigger': \r\n                case 'ServiceBusTopicTrigger': {\r\n                    const binding: any = { type: 'serviceBusTrigger' };\r\n\r\n                    const paramsMatch = this.singleParamRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding['queueName'] = paramsMatch[2];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'SignalRConnectionInfo': \r\n                case 'SignalRConnectionInfoInput': {\r\n                    const binding: any = { type: 'signalRConnectionInfo', direction: 'in' };\r\n\r\n                    const paramsMatch = this.signalRConnInfoParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.hubName = paramsMatch[1];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'SignalR': \r\n                case 'SignalROutput': {\r\n                    const binding: any = { type: 'signalR', direction: 'out' };\r\n\r\n                    const paramsMatch = this.signalRParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding['hubName'] = paramsMatch[1];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'SignalRTrigger': {\r\n                    const binding: any = { type: 'signalRTrigger' };\r\n\r\n                    const paramsMatch = this.signalRParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding['hubName'] = paramsMatch[1];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'RabbitMQ': \r\n                case 'RabbitMQOutput': {\r\n                    const binding: any = { type: 'rabbitMQ', direction: 'out' };\r\n\r\n                    const paramsMatch = this.rabbitMqParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding['queueName'] = paramsMatch[1];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'RabbitMQTrigger': {\r\n                    const binding: any = { type: 'rabbitMQTrigger' };\r\n\r\n                    const paramsMatch = this.rabbitMqParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding['queueName'] = paramsMatch[1];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'SendGrid': \r\n                case 'SendGridOutput': {\r\n                    result.push({ type: 'sendGrid', direction: 'out' });\r\n                    break;\r\n                }\r\n                case 'TwilioSms': {\r\n                    result.push({ type: 'twilioSms', direction: 'out' });\r\n                    break;\r\n                }\r\n                case 'route':\r\n                case 'HttpTrigger': {\r\n                    const binding: any = { type: 'httpTrigger', methods: [] };\r\n\r\n                    const httpTriggerRouteMatch = this.httpTriggerRouteRegex.exec(attributeCode);\r\n                    if (!!httpTriggerRouteMatch) {\r\n                        binding.route = httpTriggerRouteMatch[1];\r\n                    }\r\n\r\n                    const lowerAttributeCode = attributeCode.toLowerCase();\r\n                    for (const httpMethod of this.httpMethods) {\r\n                        \r\n                        if (lowerAttributeCode.includes(`\"${httpMethod}\"`)) {\r\n                            \r\n                            binding.methods.push(httpMethod);\r\n                        }\r\n                    }\r\n\r\n                    if (/level.anonymous/i.exec(attributeCode)) {\r\n                        \r\n                        binding.authLevel = 'anonymous';\r\n                    }\r\n\r\n                    result.push(binding);\r\n\r\n                    result.push({ type: 'http', direction: 'out' });\r\n\r\n                    break;\r\n                }\r\n                case 'orchestration_trigger':\r\n                case 'OrchestrationTrigger':\r\n                case 'DurableOrchestrationTrigger': {\r\n                    result.push({ type: 'orchestrationTrigger', direction: 'in' });\r\n                    break;\r\n                }\r\n                case 'activity_trigger':\r\n                case 'ActivityTrigger':\r\n                case 'DurableActivityTrigger': {\r\n                    result.push({ type: 'activityTrigger', direction: 'in' });\r\n                    break;\r\n                }\r\n                case 'EntityTrigger':\r\n                case 'DurableEntityTrigger': {\r\n                    result.push({ type: 'entityTrigger', direction: 'in' });\r\n                    break;\r\n                }\r\n                case 'schedule':\r\n                case 'TimerTrigger': {\r\n                    const binding: any = { type: 'timerTrigger' };\r\n\r\n                    const paramsMatch = this.singleParamRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding['schedule'] = paramsMatch[2];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'DurableClient': {\r\n                    result.push({ type: 'durableClient', direction: 'in' });\r\n                    break;\r\n                }                    \r\n                default: {\r\n                    result.push({ type: attributeName, direction: isReturn || isOut ? 'out' : 'in' });\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    protected readonly singleParamRegex = new RegExp(`(\"|nameof\\\\s*\\\\()?([\\\\w\\\\.-]+)`);\r\n    protected readonly eventHubParamsRegex = new RegExp(`\"([^\"]+)\"`);\r\n    protected readonly signalRParamsRegex = new RegExp(`\"([^\"]+)\"`);\r\n    protected readonly rabbitMqParamsRegex = new RegExp(`\"([^\"]+)\"`);\r\n    protected readonly blobParamsRegex = new RegExp(`\"([^\"]+)\"`);\r\n    protected readonly cosmosDbParamsRegex = new RegExp(`\"([^\"]+)\"(.|\\r|\\n)+?\"([^\"]+)\"`);\r\n    protected readonly signalRConnInfoParamsRegex = new RegExp(`\"([^\"]+)\"`);\r\n    protected readonly eventGridParamsRegex = new RegExp(`\"([^\"]+)\"(.|\\r|\\n)+?\"([^\"]+)\"`);\r\n\r\n    protected readonly isOutRegex = new RegExp(`^\\\\s*\\\\]\\\\s*(out |ICollector|IAsyncCollector).*?(,|\\\\()`, 'g');\r\n\r\n    protected readonly httpMethods = [`get`, `head`, `post`, `put`, `delete`, `connect`, `options`, `trace`, `patch`];\r\n    protected readonly httpTriggerRouteRegex = new RegExp(`Route\\\\s*=\\\\s*\"(.*)\"`);\r\n\r\n    protected readonly functionReturnTypeRegex = new RegExp(`public\\\\s*(static\\\\s*|async\\\\s*)*(Task\\\\s*<\\\\s*)?([\\\\w\\\\.]+)`);\r\n\r\n\r\n    protected getBindingAttributeRegex(): RegExAndPos {\r\n        \r\n        return {\r\n            regex: new RegExp(`(\\\\[|@)(<)?\\\\s*(return:)?\\\\s*(\\\\w+)`, 'g'),\r\n            pos: 4\r\n        };\r\n    }\r\n\r\n    protected getStartNewOrchestrationRegex(orchName: string): RegExp {\r\n        return new RegExp(`(StartNew|StartNewAsync|start_new|scheduleNewOrchestrationInstance|scheduleNewOrchestrationInstanceAsync)(\\\\s*<[\\\\w\\\\.-\\\\[\\\\]\\\\<\\\\>,\\\\s]+>)?\\\\s*\\\\(\\\\s*([\"'\\`]|nameof\\\\s*\\\\(\\\\s*[\\\\w\\\\.-]*|[\\\\w\\\\s\\\\.]+\\\\.\\\\s*)${orchName}\\\\s*[\"'\\\\),]{1}`, 'i');\r\n    }\r\n\r\n    protected getCallSubOrchestratorRegex(subOrchName: string): RegExp {\r\n        return new RegExp(`(CallSubOrchestrator|CallSubOrchestratorWithRetry|call_sub_orchestrator)(Async)?(\\\\s*<[\\\\w\\\\.-\\\\[\\\\]\\\\<\\\\>,\\\\s]+>)?\\\\s*\\\\(\\\\s*([\"'\\`]|nameof\\\\s*\\\\(\\\\s*[\\\\w\\\\.-]*|[\\\\w\\\\s\\\\.]+\\\\.\\\\s*)${subOrchName}\\\\s*[\"'\\\\),]{1}`, 'i');\r\n    }\r\n\r\n    protected getContinueAsNewRegex(): RegExp {\r\n        return new RegExp(`ContinueAsNew\\\\s*\\\\(`, 'i');\r\n    }\r\n\r\n    protected getRaiseEventRegex(eventName: string): RegExp {\r\n        return new RegExp(`(RaiseEvent|raise_event)(Async)?(.|\\r|\\n)*${eventName}`, 'i');\r\n    }\r\n\r\n    protected getSignalEntityRegex(entityName: string): RegExp {\r\n        return new RegExp(`${entityName}\\\\s*[\"'>]{1}`);\r\n    }\r\n\r\n    protected getWaitForExternalEventRegex(): RegExAndPos {\r\n        return {\r\n            regex: new RegExp(`(WaitForExternalEvent|wait_for_external_event)(<[\\\\s\\\\w,\\\\.-\\\\[\\\\]\\\\(\\\\)\\\\<\\\\>]+>)?\\\\s*\\\\(\\\\s*(nameof\\\\s*\\\\(\\\\s*|[\"'\\`]|[\\\\w\\\\s\\\\.]+\\\\.\\\\s*)?([\\\\s\\\\w\\\\.-]+)\\\\s*[\"'\\`\\\\),]{1}`, 'gi'),\r\n            pos: 4\r\n        };\r\n    }\r\n\r\n    protected getCallActivityRegex(activityName: string): RegExp {\r\n        return new RegExp(`(CallActivity|call_activity)[\\\\s\\\\w,\\\\.-<>\\\\[\\\\]\\\\(\\\\)\\\\?]*\\\\([\\\\s\\\\w\\\\.-]*[\"'\\`]?${activityName}\\\\s*[\"'\\`\\\\),]{1}`, 'i');\r\n    }\r\n\r\n    protected getClassDefinitionRegex(className: string): RegExp {\r\n        return new RegExp(`class\\\\s*${className}`)\r\n    }\r\n}\r\n","import { FunctionsMap } from \"./FunctionsMap\";\r\nimport { posToLineNr } from \"./traverseFunctionProjectUtils\";\r\n\r\nimport { FunctionProjectParserBase } from './functionProjectParserBase';\r\n\r\nexport class FunctionProjectScriptParser extends FunctionProjectParserBase {\r\n\r\n    public async traverseFunctions(projectFolder: string): Promise<FunctionsMap>{\r\n        \r\n        let functions: FunctionsMap;\r\n\r\n        functions = await this._fileSystemWrapper.readFunctionsJson(projectFolder, this._log);\r\n\r\n        // Now enriching it with more info extracted from code\r\n        functions = await this.mapOrchestratorsAndActivitiesAsync(functions, projectFolder);\r\n\r\n        return functions;\r\n    }\r\n\r\n    protected async getFunctionsAndTheirCodesAsync(functionNames: string[], hostJsonFolder: string): Promise<{ name: string; code: string; filePath: string; pos: number; lineNr: number; }[]> {\r\n\r\n        const promises = functionNames.map(async name => {\r\n\r\n            let match = await this._fileSystemWrapper.findFileRecursivelyAsync(\r\n                this._fileSystemWrapper.joinPath(hostJsonFolder, name),\r\n                '(index\\\\.ts|index\\\\.js|__init__\\\\.py)$',\r\n                true);\r\n            \r\n            if (!match) {\r\n                return undefined;\r\n            }\r\n    \r\n            const pos = !match.pos ? 0 : match.pos;\r\n            const lineNr = posToLineNr(match.code, pos);\r\n    \r\n            return { name, code: match.code, filePath: match.filePath, pos, lineNr };\r\n        });\r\n    \r\n        return (await Promise.all(promises)).filter(f => !!f) as any;\r\n    }\r\n}\r\n\r\n","import { FunctionsMap } from \"./FunctionsMap\";\r\nimport { getCodeInBrackets, posToLineNr } from \"./traverseFunctionProjectUtils\";\r\n\r\nimport { RegExAndPos } from \"./fileSystemWrapperBase\";\r\nimport { FunctionProjectCodeParser } from \"./functionProjectCodeParser\";\r\n\r\nexport class JavaFunctionProjectParser extends FunctionProjectCodeParser {\r\n\r\n    protected async getFunctionsAndTheirCodesAsync(functionNames: string[], hostJsonFolder: string): Promise<{ name: string; code: string; filePath: string; pos: number; lineNr: number; }[]> {\r\n\r\n        const promises = functionNames.map(async name => {\r\n\r\n            const match = await this._fileSystemWrapper.findFileRecursivelyAsync(hostJsonFolder, '.+\\\\.java$', true, this.getFunctionStartRegex(name));\r\n            \r\n            if (!match) {\r\n                return undefined;\r\n            }\r\n\r\n            const code = getCodeInBrackets(match.code!, match.pos! + match.length!, '{', '}', '\\n').code;\r\n            const pos = !match.pos ? 0 : match.pos;\r\n            const lineNr = posToLineNr(match.code, pos);\r\n\r\n            return { name, code, filePath: match.filePath, pos, lineNr };\r\n        });\r\n\r\n        return (await Promise.all(promises)).filter(f => !!f) as any;\r\n    }\r\n\r\n    protected async traverseProjectCode(projectFolder: string): Promise<FunctionsMap> {\r\n\r\n        const result: any = {};\r\n\r\n        for await (const func of this._fileSystemWrapper.findFunctionsRecursivelyAsync(projectFolder, new RegExp('.+\\\\.java$', 'i'), this.getFunctionAttributeRegex())) {\r\n            \r\n            const bindings = this.tryExtractBindings(func.declarationCode);\r\n    \r\n            result[func.functionName] = {\r\n\r\n                filePath: func.filePath,\r\n                pos: func.pos,\r\n                lineNr: func.lineNr,\r\n\r\n                bindings: [...bindings]\r\n            };\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    protected getFunctionAttributeRegex(): RegExAndPos {\r\n        return {\r\n            regex: new RegExp(`@\\\\s*FunctionName\\\\s*\\\\(([\"\\\\w\\\\s\\\\.\\\\(\\\\)-]+)\\\\)`, 'g'),\r\n            pos: 1\r\n        };\r\n    }\r\n}","import { FunctionsMap } from \"./FunctionsMap\";\r\nimport { posToLineNr } from \"./traverseFunctionProjectUtils\";\r\n\r\nimport { FunctionProjectParserBase } from './functionProjectParserBase';\r\nimport { RegExAndPos } from \"./fileSystemWrapperBase\";\r\n\r\nexport class PowershellFunctionProjectParser extends FunctionProjectParserBase {\r\n\r\n    public async traverseFunctions(projectFolder: string): Promise<FunctionsMap>{\r\n        \r\n        let functions: FunctionsMap;\r\n\r\n        functions = await this._fileSystemWrapper.readFunctionsJson(projectFolder, this._log);\r\n\r\n        // Now enriching it with more info extracted from code\r\n        functions = await this.mapOrchestratorsAndActivitiesAsync(functions, projectFolder);\r\n\r\n        return functions;\r\n    }\r\n\r\n    protected async getFunctionsAndTheirCodesAsync(functionNames: string[], hostJsonFolder: string): Promise<{ name: string; code: string; filePath: string; pos: number; lineNr: number; }[]> {\r\n\r\n        const promises = functionNames.map(async name => {\r\n\r\n            let scriptFile = 'run\\\\.ps1$';\r\n\r\n            const functionJsonMatch = await this._fileSystemWrapper.findFileRecursivelyAsync(\r\n                this._fileSystemWrapper.joinPath(hostJsonFolder, name),\r\n                'function.json$',\r\n                true\r\n            );\r\n\r\n            if (!!functionJsonMatch) {\r\n                \r\n                const functionJson = JSON.parse(functionJsonMatch.code!);\r\n\r\n                if (!!functionJson.scriptFile) {\r\n                    scriptFile = functionJson.scriptFile.replace('.', '\\\\.');\r\n                }\r\n            }\r\n\r\n            const match = await this._fileSystemWrapper.findFileRecursivelyAsync(\r\n                this._fileSystemWrapper.joinPath(hostJsonFolder, name),\r\n                scriptFile,\r\n                true\r\n            );\r\n            \r\n            if (!match) {\r\n                return undefined;\r\n            }\r\n    \r\n            const pos = !match.pos ? 0 : match.pos;\r\n            const lineNr = posToLineNr(match.code, pos);\r\n    \r\n            return { name, code: match.code, filePath: match.filePath, pos, lineNr };\r\n        });\r\n    \r\n        return (await Promise.all(promises)).filter(f => !!f) as any;\r\n    }\r\n\r\n    protected getStartNewOrchestrationRegex(orchName: string): RegExp {\r\n        return new RegExp(`(Start-DurableOrchestration|Start-NewOrchestration).*-FunctionName\\\\s*[\"']${orchName}[\"']`, 'i');\r\n    }\r\n\r\n    protected getCallActivityRegex(activityName: string): RegExp {\r\n        return new RegExp(`(Invoke-DurableActivity|Invoke-ActivityFunction).*-FunctionName\\\\s*[\"']${activityName}[\"']`, 'i');\r\n    }\r\n\r\n    protected getRaiseEventRegex(eventName: string): RegExp {\r\n        return new RegExp(`Send-DurableExternalEvent.*-EventName\\\\s*[\"']${eventName}[\"']`, 'i');\r\n    }\r\n\r\n    protected getWaitForExternalEventRegex(): RegExAndPos {\r\n        return {\r\n            regex: new RegExp(`Start-DurableExternalEventListener.*-EventName\\\\s*[\"']([\\\\s\\\\w\\\\.-]+)[\"']`, 'gi'),\r\n            pos: 1\r\n        };\r\n    }\r\n}\r\n","import { FunctionsMap } from \"./FunctionsMap\";\r\nimport { getCodeInBrackets, posToLineNr } from \"./traverseFunctionProjectUtils\";\r\n\r\nimport { RegExAndPos } from \"./fileSystemWrapperBase\";\r\nimport { FunctionProjectCodeParser } from \"./functionProjectCodeParser\";\r\n\r\nexport class PythonV2FunctionProjectParser extends FunctionProjectCodeParser {\r\n\r\n    protected async getFunctionsAndTheirCodesAsync(functionNames: string[], hostJsonFolder: string): Promise<{ name: string; code: string; filePath: string; pos: number; lineNr: number; }[]> {\r\n\r\n        const promises = functionNames.map(async name => {\r\n\r\n            const match = await this._fileSystemWrapper.findFileRecursivelyAsync(hostJsonFolder, '.+\\\\.py$', true, this.getFunctionStartRegex(name));\r\n            \r\n            if (!match) {\r\n                return undefined;\r\n            }\r\n\r\n            const { declarationCode, bodyCode } = this.getFunctionCode(match.code!, match.pos!);\r\n\r\n            const pos = !match.pos ? 0 : match.pos;\r\n            const lineNr = posToLineNr(match.code, pos);\r\n\r\n            return { name, code: bodyCode, filePath: match.filePath, pos, lineNr };\r\n        });\r\n\r\n        return (await Promise.all(promises)).filter(f => !!f) as any;\r\n    }\r\n\r\n    protected async traverseProjectCode(projectFolder: string): Promise<FunctionsMap> {\r\n\r\n        const result: any = {};\r\n\r\n        for await (const func of this.findFunctionsRecursivelyAsync(projectFolder)) {\r\n            \r\n            const bindings = this.tryExtractBindings(func.declarationCode);\r\n    \r\n            result[func.functionName] = {\r\n\r\n                filePath: func.filePath,\r\n                pos: func.pos,\r\n                lineNr: func.lineNr,\r\n\r\n                bindings: [...bindings]\r\n            };\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    async * findFunctionsRecursivelyAsync(folder: string): AsyncGenerator<any> {\r\n\r\n        const fileNameRegex = new RegExp('.+\\\\.py$', 'i');\r\n        const functionAttributeRegex = this.getFunctionAttributeRegex();\r\n\r\n        const functionNameRegex = new RegExp(`\\\\.\\\\s*function_name\\\\s*\\\\(\\\\s*name\\\\s*=\\\\s*[\"']([\\\\w-]+)[\"']`);\r\n        \r\n        for await (const fullPath of this._fileSystemWrapper.findFilesRecursivelyAsync(folder, fileNameRegex)) {\r\n\r\n            const code = await this._fileSystemWrapper.readFile(fullPath);\r\n\r\n            let match: RegExpExecArray | null;\r\n            while (!!(match = functionAttributeRegex.regex.exec(code))) {\r\n\r\n                let functionName = match[functionAttributeRegex.pos];\r\n\r\n                let { declarationCode, bodyCode } = this.getFunctionCode(code, match.index);\r\n\r\n                const functionNameMatch = functionNameRegex.exec(declarationCode);\r\n                if (!!functionNameMatch) {\r\n                 \r\n                    functionName = functionNameMatch[1];\r\n\r\n                    // Need to remove this line so that it does not appear as binding\r\n                    declarationCode = declarationCode.replace('function_name', '');\r\n                }\r\n\r\n                yield {\r\n                    functionName,\r\n                    filePath: fullPath,\r\n                    pos: match.index,\r\n                    lineNr: posToLineNr(code, match.index),\r\n\r\n                    declarationCode,\r\n                    bodyCode\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    private getFunctionCode(code: string, endPos: number): { declarationCode: string, bodyCode: string } {\r\n\r\n        let declarationCode = '';\r\n        let bodyCode = '';\r\n\r\n        const defRegex = new RegExp('^(async)?\\\\s*def ', 'gm');\r\n        const nextMethodRegex = new RegExp('^[^\\\\s]', 'gm');\r\n\r\n        defRegex.lastIndex = endPos;\r\n        const defMatch = defRegex.exec(code);\r\n        if (!!defMatch) {\r\n            \r\n            declarationCode = code.substring(endPos, defMatch.index);\r\n\r\n            endPos = defMatch.index + defMatch[0].length;\r\n\r\n            nextMethodRegex.lastIndex = endPos;\r\n            const nextMethodMatch = nextMethodRegex.exec(code);\r\n            if (!!nextMethodMatch) {\r\n\r\n                bodyCode = code.substring(endPos, nextMethodMatch.index);\r\n                \r\n            } else {\r\n\r\n                bodyCode = code.substring(endPos);\r\n            }\r\n\r\n        } else {\r\n\r\n            declarationCode = code.substring(endPos);\r\n            bodyCode = code.substring(endPos);\r\n        }\r\n\r\n        return { declarationCode, bodyCode };\r\n    }\r\n\r\n    protected getFunctionAttributeRegex(): RegExAndPos {\r\n        return {\r\n            regex: new RegExp(`@[\\\\w\\\\s]+\\\\.\\\\s*(function_name|route|blob_trigger|cosmos_db_trigger|event_hub_message_trigger|queue_trigger|service_bus_queue_trigger|service_bus_topic_trigger|orchestration_trigger|activity_trigger|schedule)(.|\\r|\\n)+?def\\\\s+([\\\\w-]+)`, 'g'),\r\n            pos: 3\r\n        };\r\n    }\r\n\r\n    protected getFunctionStartRegex(funcName: string): RegExp {\r\n        return new RegExp(`(@[\\\\w\\\\s]+\\\\.\\\\s*function_name\\\\s*\\\\(\\\\s*name\\\\s*=\\\\s*[\"']${funcName}[\"']|^(async)?\\\\s*def\\\\s+${funcName})`, 'm')\r\n    }\r\n\r\n    protected getBindingAttributeRegex(): RegExAndPos {\r\n        \r\n        return {\r\n            regex: new RegExp(`@[\\\\w\\\\s]+\\\\.\\\\s*(\\\\w+)\\\\s*\\\\(`, 'g'),\r\n            pos: 1\r\n        };\r\n    }\r\n\r\n    protected getStartNewOrchestrationRegex(orchName: string): RegExp {\r\n        \r\n        return new RegExp(`\\\\.\\\\s*start_new\\\\s*\\\\(\\\\s*[\"']${orchName}[\"']`);\r\n    }\r\n}","\r\nexport function cleanupFunctionName(name: string): string {\r\n\r\n    if (!name) {\r\n        return name;\r\n    }\r\n\r\n    const nameofMatch = new RegExp(`nameof\\\\s*\\\\(\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\)`).exec(name);\r\n    if (!!nameofMatch) {\r\n\r\n        return removeNamespace(nameofMatch[1]);\r\n    }\r\n\r\n    name = name.trim();\r\n\r\n    if (name.startsWith('\"')) {\r\n        return name.replace(/^\"/, '').replace(/\"$/, '');\r\n    }\r\n\r\n    return removeNamespace(name);\r\n}\r\n\r\nexport function removeNamespace(name: string): string {\r\n\r\n    if (!name) {\r\n        return name;\r\n    }\r\n\r\n    const dotPos = name.lastIndexOf('.');\r\n    if (dotPos >= 0) {\r\n        name = name.substring(dotPos + 1);\r\n    }\r\n\r\n    return name.trim();\r\n}\r\n\r\n// Primitive way of getting a line number out of symbol position\r\nexport function posToLineNr(code: string | undefined, pos: number): number {\r\n    if (!code) {\r\n        return 0;\r\n    }\r\n    const lineBreaks = code.substr(0, pos).match(/(\\r\\n|\\r|\\n)/g);\r\n    return !lineBreaks ? 1 : lineBreaks.length + 1;\r\n}\r\n\r\n// Complements regex's inability to keep up with nested brackets\r\nexport function getCodeInBrackets(str: string, startFrom: number, openingBracket: string, closingBracket: string, mustHaveSymbols: string = ''): { code: string, openBracketPos: number } {\r\n\r\n    var bracketCount = 0, openBracketPos = -1, mustHaveSymbolFound = !mustHaveSymbols;\r\n\r\n    for (var i = startFrom; i < str.length; i++) {\r\n\r\n        switch (str[i]) {\r\n            case openingBracket:\r\n\r\n                if (bracketCount <= 0) {\r\n                    openBracketPos = i;\r\n                }\r\n                bracketCount++;\r\n\r\n                break;\r\n            case closingBracket:\r\n\r\n                bracketCount--;\r\n                if (bracketCount <= 0 && mustHaveSymbolFound) {\r\n                    return { code: str.substring(startFrom, i + 1), openBracketPos: openBracketPos - startFrom };\r\n                }\r\n                \r\n                break;\r\n        }\r\n\r\n        if (bracketCount > 0 && mustHaveSymbols.includes(str[i])) {\r\n            mustHaveSymbolFound = true;\r\n        }\r\n    }\r\n    return { code: '', openBracketPos: -1 };\r\n}\r\n\r\n// Complements regex's inability to keep up with nested brackets\r\nexport function getCodeInBracketsReverse(str: string, openingBracket: string, closingBracket: string): { code: string, openBracketPos: number } {\r\n\r\n    var bracketCount = 0, closingBracketPos = 0;\r\n    \r\n    for (var i = str.length - 1; i >= 0; i--) {\r\n\r\n        switch (str[i]) {\r\n            case closingBracket:\r\n\r\n                if (bracketCount <= 0) {\r\n                    closingBracketPos = i;\r\n                }\r\n                bracketCount++;\r\n\r\n                break;\r\n            case openingBracket:\r\n\r\n                bracketCount--;\r\n                if (bracketCount <= 0 ) {\r\n                    return { code: str.substring(0, closingBracketPos + 1), openBracketPos: i };\r\n                }\r\n                \r\n                break;\r\n        }\r\n    }\r\n    return { code: '', openBracketPos: -1 };\r\n}\r\n","module.exports = require(\"vscode\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import * as vscode from 'vscode';\r\n\r\nimport { FileSystemWrapper } from './FileSystemWrapper';\r\nimport { FunctionGraphView } from './FunctionGraphView';\r\n\r\nlet graphViews: FunctionGraphView[] = [];\r\n\r\nconst fsWrapper = new FileSystemWrapper();\r\n\r\nconst MaxProjectsToShowAutomatically = 5;\r\n\r\nasync function showAllFunctionProjects(context: vscode.ExtensionContext) {\r\n\r\n\tif (!vscode.workspace.workspaceFolders) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst hostJsonFolders = [];\r\n\r\n\ttry{\r\n\r\n\t\tfor (const folder of vscode.workspace.workspaceFolders) {\r\n\r\n\t\t\tfor await (const hostJsonPath of fsWrapper.findFilesRecursivelyAsync(folder.uri.toString(), new RegExp('host.json', 'i'))) {\r\n\t\t\t\t\r\n\t\t\t\thostJsonFolders.push(fsWrapper.dirName(hostJsonPath));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (hostJsonFolders.length > MaxProjectsToShowAutomatically) {\r\n\t\t\t\r\n\t\t\tconst userResponse = await vscode.window.showWarningMessage(\r\n\t\t\t\t`az-func-as-a-graph found ${hostJsonFolders.length} Azure Functions projects in current workspace. Do you want to visualize all of them?`,\r\n\t\t\t\t'Yes', 'No');\r\n\r\n\t\t\tif (userResponse !== 'Yes') {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t} catch (err: any) {\r\n\t\t\r\n\t\tvscode.window.showErrorMessage(`az-func-as-a-graph failed. ${err.message ?? err}`);\r\n\t}\r\n\r\n\tfor (const hostJsonFolder of hostJsonFolders) {\r\n\t\t\r\n\t\tgraphViews.push(new FunctionGraphView(context, vscode.Uri.parse(hostJsonFolder)));\r\n\t}\r\n}\r\n\r\nexport async function activate(context: vscode.ExtensionContext) {\r\n\r\n\tcontext.subscriptions.push(\r\n\r\n\t\tvscode.commands.registerCommand('az-func-as-a-graph.ShowGraph', async (item?: vscode.Uri) => {\r\n\r\n\t\t\tif (!!item) {\r\n\t\t\t\t\r\n\t\t\t\tconst pathToHostJson = item.toString();\r\n\r\n\t\t\t\tif (pathToHostJson.toLowerCase().endsWith('host.json')) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tgraphViews.push(new FunctionGraphView(context, vscode.Uri.parse(fsWrapper.dirName(pathToHostJson))));\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tawait showAllFunctionProjects(context);\r\n\t\t})\t\t\r\n\t);\r\n\r\n\tif (!vscode.workspace.workspaceFolders) {\r\n\t\treturn;\r\n\t}\r\n\r\n    const config = vscode.workspace.getConfiguration('az-func-as-a-graph');\r\n\r\n\tif (!!config.get<boolean>('showGraphAtStartup', true)) {\r\n\r\n\t\t// Showing graphs of all Functions in the workspace\r\n\t\tawait showAllFunctionProjects(context);\r\n\t}\r\n}\r\n\r\n// This method is called when your extension is deactivated\r\nexport function deactivate() {\r\n\r\n\tfor (const view of graphViews) {\r\n\t\t\r\n\t\tview.cleanup();\r\n\t}\r\n}"],"names":["FileSystemWrapper","FileSystemWrapperBase","joinPath","path1","path2","vscode","Uri","parse","toString","dirName","i","lastIndexOf","Error","substring","async","path","uri","bytes","workspace","fs","readFile","TextDecoder","decode","stat","type","FileType","Directory","readDirectory","map","f","File","err","FunctionGraphView","constructor","_context","_functionProjectUri","_webViewPanel","this","_staticsFolder","extensionUri","showWebView","cleanup","dispose","title","fsPath","panel","window","createWebviewPanel","viewType","ViewColumn","One","retainContextWhenHidden","enableScripts","localResourceRoots","fileUri","then","htmlBytes","html","fixLinksToStatics","webview","embedTheme","showErrorMessage","message","onDidReceiveMessage","request","handleMessageFromWebView","undefined","subscriptions","includes","activeColorTheme","kind","replace","webView","showInformationMessage","data","looksLikeSvg","showSaveDialog","defaultUri","file","filters","filePath","TextEncoder","encode","writeFile","_traversalResult","JSON","stringify","functionName","functionOrProxy","startsWith","proxies","substr","functions","showTextDocument","ed","pos","document","positionAt","selection","Selection","revealRange","Range","FunctionProjectParser","parseFunctions","console","log","res","Object","keys","length","postMessage","catch","originalHtml","staticsFolder","resultHtml","regex","match","exec","relativePath","localPath","newPath","asWebviewUri","endsWith","toLowerCase","CSharpFunctionProjectParser","FunctionProjectCodeParser","functionNames","hostJsonFolder","promises","name","_fileSystemWrapper","findFileRecursivelyAsync","getFunctionStartRegex","lineNr","posToLineNr","code","getCodeInBrackets","Promise","all","filter","projectFolder","result","fileNameRegex","RegExp","func","findFunctionsRecursivelyAsync","getFunctionAttributeRegex","bindings","tryExtractBindings","declarationCode","some","b","push","extractOutputBindings","functionCode","returnTypeMatch","functionReturnTypeRegex","returnTypeName","removeNamespace","returnTypeDefinition","getClassDefinitionRegex","classBody","FSharpFunctionProjectParser","ExcludedFolders","readDir","fullPath","functionJsonFilePath","isDirectory","functionJsonExists","pathExists","functionJsonString","functionJson","isCalledBy","isSignalledBy","proxiesJsonPath","proxiesJsonString","notAddedToCsProjFile","isCSharpProjectAsync","csProjFile","proxiesJsonEntryRegex","proxyName","proxy","warningNotAddedToCsProjFile","index","fn","firstFunctionJsonFile","pyFileMatch","functionJsonFileMatch","folder","fileName","returnFileContents","pattern","subFolders","subFolder","findFilesRecursivelyAsync","functionAttributeRegex","cleanupFunctionName","functionAttributeEndPos","body","openBracketPos","bodyCode","FunctionProjectParserBase","traverseProjectCode","mapOrchestratorsAndActivitiesAsync","funcName","static","fileSystemWrapper","hostJsonMatch","parser","isFSharpProjectAsync","isJavaProjectAsync","JavaFunctionProjectParser","isPowershellProjectAsync","PowershellFunctionProjectParser","isPythonV2ProjectAsync","PythonV2FunctionProjectParser","FunctionProjectScriptParser","traverseFunctions","readProxiesJson","_log","singleParamRegex","eventHubParamsRegex","signalRParamsRegex","rabbitMqParamsRegex","blobParamsRegex","cosmosDbParamsRegex","signalRConnInfoParamsRegex","eventGridParamsRegex","isOutRegex","httpMethods","httpTriggerRouteRegex","orchestratorNames","orchestrators","getFunctionsAndTheirCodesAsync","activityNames","activities","entityNames","entities","otherFunctionNames","otherFunctions","orch","getStartNewOrchestrationRegex","subOrch","getCallSubOrchestratorRegex","mapActivitiesToOrchestrator","getContinueAsNewRegex","isCalledByItself","eventNames","getEventNames","eventName","getRaiseEventRegex","signalName","entity","getSignalEntityRegex","concat","orchestratorCode","getWaitForExternalEventRegex","activityName","getCallActivityRegex","funcCode","getBindingAttributeRegex","isReturn","attributeName","attributeCodeStartIndex","attributeCode","lastIndex","isOut","binding","direction","paramsMatch","tableName","databaseName","collectionName","topicEndpointUri","topicKeySetting","eventHubName","brokerList","hubName","methods","httpTriggerRouteMatch","route","lowerAttributeCode","httpMethod","authLevel","orchName","subOrchName","entityName","className","readFunctionsJson","scriptFile","functionJsonMatch","getFunctionCode","functionNameRegex","functionNameMatch","endPos","defRegex","nextMethodRegex","defMatch","nextMethodMatch","dotPos","trim","nameofMatch","lineBreaks","str","startFrom","openingBracket","closingBracket","mustHaveSymbols","bracketCount","mustHaveSymbolFound","closingBracketPos","module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","graphViews","fsWrapper","MaxProjectsToShowAutomatically","showAllFunctionProjects","context","workspaceFolders","hostJsonFolders","hostJsonPath","showWarningMessage","commands","registerCommand","item","pathToHostJson","getConfiguration","get","view"],"sourceRoot":""}