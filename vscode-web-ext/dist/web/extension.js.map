{"version":3,"file":"extension.js","mappings":"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","sources":["../.././src/web/FileSystemWrapper.ts","../.././src/web/FunctionGraphView.ts","../.././src/web/func-project-parser/fileSystemWrapperBase.ts","../.././src/web/func-project-parser/functionProjectParser.ts","../.././src/web/func-project-parser/traverseFunctionProjectUtils.ts","../../external commonjs \"vscode\"","../../webpack/bootstrap","../.././src/web/extension.ts"],"sourcesContent":["import * as vscode from 'vscode';\r\n\r\nimport { FileSystemWrapperBase } from './func-project-parser/fileSystemWrapperBase';\r\n\r\nexport class FileSystemWrapper extends FileSystemWrapperBase {\r\n\r\n\tpublic joinPath(path1: string, path2: string): string {\r\n\r\n\t\treturn vscode.Uri.joinPath(vscode.Uri.parse(path1), path2).toString();\r\n\t}\r\n\r\n\tpublic dirName(path1: string): string {\r\n\r\n\t\tconst i = path1.lastIndexOf('/');\r\n\r\n\t\tif (i < 0) {\r\n\t\t\tthrow new Error(`Failed to extract parent folder name from path ${path1}. The path does not contain a separator.`);\r\n\t\t}\r\n\r\n\t\treturn path1.substring(0, i);\r\n\t}\r\n\r\n\tprotected async readFile(path: string): Promise<string> {\r\n\r\n\t\tconst uri = vscode.Uri.parse(path);\r\n\r\n\t\tconst bytes = await vscode.workspace.fs.readFile(uri);\r\n\r\n\t\treturn new TextDecoder().decode(bytes);\r\n\t}\r\n\r\n\tprotected async isDirectory(path: string): Promise<boolean> {\r\n\r\n\t\tconst uri = vscode.Uri.parse(path);\r\n\r\n\t\tconst stat = await vscode.workspace.fs.stat(uri);\r\n\r\n\t\treturn stat.type === vscode.FileType.Directory;\r\n\t}\r\n\r\n\tprotected async readDir(path: string): Promise<string[]> {\r\n\r\n\t\tconst uri = vscode.Uri.parse(path);\r\n\r\n\t\tconst files = await vscode.workspace.fs.readDirectory(uri);\r\n\r\n\t\treturn files.map(f => f[0]);\r\n\t}\r\n\r\n\tpublic async pathExists(path: string): Promise<boolean> {\r\n\r\n\t\tconst uri = vscode.Uri.parse(path);\r\n\r\n\t\ttry {\r\n\t\t\t\r\n\t\t\tconst stat = await vscode.workspace.fs.stat(uri);\r\n\r\n\t\t\treturn stat.type === vscode.FileType.File || stat.type === vscode.FileType.Directory;\r\n\r\n\t\t} catch (err) {\r\n\t\t\r\n\t\t\treturn false;\r\n\t\t}\t\t\r\n\t}\r\n}\r\n","import * as vscode from 'vscode';\r\n\r\nimport { FunctionsMap, ProxiesMap } from './func-project-parser/FunctionsMap';\r\nimport { FunctionProjectParser } from './func-project-parser/functionProjectParser';\r\nimport { FileSystemWrapper } from './FileSystemWrapper';\r\n\r\nexport type TraversalResult = {\r\n    functions: FunctionsMap;\r\n    proxies: ProxiesMap;\r\n};\r\n\r\n// Represents the function graph view\r\nexport class FunctionGraphView\r\n{\r\n    constructor(private _context: vscode.ExtensionContext,\r\n        private _functionProjectUri: vscode.Uri) {\r\n        \r\n        this._staticsFolder = vscode.Uri.joinPath(this._context.extensionUri, 'HtmlStatics');\r\n\r\n        this._webViewPanel = this.showWebView();\r\n    }\r\n\r\n    // Closes this web view\r\n    cleanup(): void {\r\n\r\n        if (!!this._webViewPanel) {\r\n            this._webViewPanel.dispose();\r\n        }\r\n    }\r\n\r\n    // Path to html statics\r\n    private _staticsFolder: vscode.Uri;\r\n\r\n    // Reference to the already opened WebView with the main page\r\n    private _webViewPanel: vscode.WebviewPanel | null = null;    \r\n\r\n    // Functions and proxies currently shown\r\n    private _traversalResult?: TraversalResult;\r\n\r\n    private static readonly viewType = 'az-func-as-a-graph';\r\n\r\n    // Opens a WebView with function graph page in it\r\n    private showWebView(): vscode.WebviewPanel {\r\n\r\n        const title = `Functions Graph (${this._functionProjectUri.fsPath})`;\r\n\r\n        const panel = vscode.window.createWebviewPanel(\r\n            FunctionGraphView.viewType,\r\n            title,\r\n            vscode.ViewColumn.One,\r\n            {\r\n                retainContextWhenHidden: true,\r\n                enableScripts: true,\r\n                localResourceRoots: [this._staticsFolder]\r\n            }\r\n        );\r\n\r\n        const fileUri = vscode.Uri.joinPath(this._staticsFolder, 'index.html');\r\n\r\n        vscode.workspace.fs.readFile(fileUri).then(htmlBytes => {\r\n\r\n            let html = new TextDecoder().decode(htmlBytes);\r\n\r\n            html = this.fixLinksToStatics(html, this._staticsFolder, panel.webview);\r\n            html = this.embedTheme(html);\r\n    \r\n            panel.webview.html = html;\r\n    \r\n        }, err => {\r\n\r\n            vscode.window.showErrorMessage(`az-func-as-a-graph failed. ${err.message ?? err}`);\r\n        });\r\n\r\n        // handle events from WebView\r\n        panel.webview.onDidReceiveMessage(request => this.handleMessageFromWebView(panel.webview, request), undefined, this._context.subscriptions);\r\n        \r\n        return panel;\r\n    }\r\n\r\n    // Embeds the current color theme\r\n    private embedTheme(html: string): string {\r\n\r\n        if ([2, 3].includes((vscode.window as any).activeColorTheme.kind)) {\r\n            return html.replace('<script>var ClientConfig={}</script>', '<script>var ClientConfig={\\'theme\\':\\'dark\\'}</script>');\r\n        }\r\n        return html;\r\n    }\r\n\r\n    // Does communication between code in WebView and this class\r\n    private handleMessageFromWebView(webView: vscode.Webview, request: any): void {\r\n\r\n        switch (request.kind) {\r\n\r\n            case 'ShowMessage':\r\n\r\n                vscode.window.showInformationMessage(request.data);\r\n                \r\n                return;\r\n\r\n            case 'ShowError':\r\n\r\n                vscode.window.showErrorMessage(`az-func-as-a-graph failed. ${request.data}`);\r\n                \r\n                return;\r\n            \r\n            case 'SaveAs':\r\n\r\n                // Just to be extra sure...\r\n                if (!this.looksLikeSvg(request.data)) {\r\n                    vscode.window.showErrorMessage(`Invalid data format. Save failed.`);\r\n                    return;\r\n                }\r\n                \r\n                // Saving some file to local hard drive\r\n                vscode.window.showSaveDialog({ defaultUri: vscode.Uri.file('func-map.svg'), filters: { 'SVG Images': ['svg'] } }).then(filePath => {\r\n\r\n                    if (!filePath) { \r\n                        return;\r\n                    }\r\n\r\n                    const bytes = new TextEncoder().encode(request.data);\r\n\r\n                    vscode.workspace.fs.writeFile(filePath, bytes).then(() => {\r\n\r\n                        vscode.window.showInformationMessage(`SVG image saved to ${filePath}`);\r\n\r\n                    }, err => {\r\n\r\n                        vscode.window.showErrorMessage(`Failed to save. ${err.message ?? err}`);\r\n                    });\r\n\r\n                });\r\n                return;\r\n            \r\n            case 'SaveFunctionGraphAsJson':\r\n\r\n                if (!this._traversalResult) {\r\n                    return;\r\n                }\r\n                \r\n                // Saving some file to local hard drive\r\n                vscode.window.showSaveDialog({ defaultUri: vscode.Uri.file('func-map.json'), filters: { 'JSON': ['json'] } }).then(filePath => {\r\n\r\n                    if (!filePath) { \r\n                        return;\r\n                    }\r\n\r\n                    const bytes = new TextEncoder().encode(JSON.stringify(this._traversalResult, null, 3));\r\n\r\n                    vscode.workspace.fs.writeFile(filePath, bytes).then(() => {\r\n\r\n                        vscode.window.showInformationMessage(`Diagram JSON saved to ${filePath}`);\r\n\r\n                    }, err => {\r\n\r\n                        vscode.window.showErrorMessage(`Failed to save. ${err.message ?? err}`);\r\n                    });\r\n\r\n                });\r\n                return;\r\n            \r\n            case 'GotoFunctionCode':\r\n\r\n                if (!this._traversalResult) {\r\n                    return;\r\n                }\r\n\r\n                const functionName = request.data;\r\n                var functionOrProxy: any = null;\r\n\r\n                if (functionName.startsWith('proxy.')) {\r\n            \r\n                    functionOrProxy = this._traversalResult.proxies[functionName.substr(6)];\r\n    \r\n                } else {\r\n    \r\n                    functionOrProxy = this._traversalResult.functions[functionName];\r\n                }\r\n    \r\n                vscode.window.showTextDocument(vscode.Uri.parse(functionOrProxy.filePath)).then(ed => {\r\n\r\n                    const pos = ed.document.positionAt(!!functionOrProxy.pos ? functionOrProxy.pos : 0);\r\n\r\n                    ed.selection = new vscode.Selection(pos, pos);\r\n                    ed.revealRange(new vscode.Range(pos, pos));\r\n\r\n                });\r\n\r\n                return;\r\n            \r\n            case 'Refresh':\r\n\r\n                FunctionProjectParser.parseFunctions(this._functionProjectUri.toString(), new FileSystemWrapper(), console.log).then(res => {\r\n\r\n                    this._traversalResult = res;\r\n                    webView.postMessage(this._traversalResult);\r\n        \r\n                }).catch(err => {\r\n\r\n                    this._traversalResult = undefined;\r\n                    webView.postMessage(undefined);\r\n                    \r\n                    vscode.window.showErrorMessage(`az-func-as-a-graph failed. ${err.message ?? err}`);\r\n                });\r\n                    \r\n                return;\r\n        }\r\n    }\r\n\r\n    private fixLinksToStatics(originalHtml: string, staticsFolder: vscode.Uri, webView: vscode.Webview): string {\r\n\r\n        var resultHtml: string = originalHtml;\r\n    \r\n        const regex = / (href|src)=\"\\/([0-9a-z.\\/]+)\"/ig;\r\n        var match: RegExpExecArray | null;\r\n        while (match = regex.exec(originalHtml)) {\r\n    \r\n            const relativePath = match[2];\r\n            const localPath = vscode.Uri.joinPath(staticsFolder, relativePath)\r\n            const newPath = webView.asWebviewUri(localPath).toString();\r\n    \r\n            resultHtml = resultHtml.replace(`/${relativePath}`, newPath);\r\n        }\r\n    \r\n        return resultHtml;\r\n    }\r\n\r\n    // Validates incoming SVG, just to be extra sure...\r\n    private looksLikeSvg(data: string): boolean {\r\n        return data.startsWith('<svg') && data.endsWith('</svg>') && !data.toLowerCase().includes('<script');\r\n    }\r\n}","import { cleanupFunctionName, getCodeInBrackets, posToLineNr } from './traverseFunctionProjectUtils';\r\nimport { FunctionsMap, ProxiesMap } from './FunctionsMap';\r\n\r\nconst ExcludedFolders = ['node_modules', 'obj', '.vs', '.vscode', '.env', '.python_packages', '.git', '.github'];\r\n\r\nexport abstract class FileSystemWrapperBase {\r\n\r\n    public abstract dirName(path1: string): string;\r\n\r\n    public abstract joinPath(path1: string, path2: string): string;\r\n\r\n    protected abstract readFile(path: string): Promise<string>;\r\n\r\n    protected abstract isDirectory(path: string): Promise<boolean>;\r\n\r\n    protected abstract readDir(path: string): Promise<string[]>;\r\n\r\n    protected abstract pathExists(path: string): Promise<boolean>;\r\n\r\n    async readFunctionsJson(hostJsonFolder: string, log: (s: any) => void): Promise<FunctionsMap> {\r\n\r\n        let functions: FunctionsMap = {};\r\n    \r\n            // Reading function.json files, in parallel\r\n            const promises = (await this.readDir(hostJsonFolder)).map(async functionName => {\r\n    \r\n                const fullPath = this.joinPath(hostJsonFolder, functionName);\r\n                const functionJsonFilePath = this.joinPath(fullPath, 'function.json');\r\n    \r\n                const isDirectory = await this.isDirectory(fullPath);\r\n                const functionJsonExists = await this.pathExists(functionJsonFilePath);\r\n    \r\n                if (isDirectory && functionJsonExists) {\r\n    \r\n                    try {\r\n                        const functionJsonString = await this.readFile(functionJsonFilePath);\r\n                        const functionJson = JSON.parse(functionJsonString);\r\n    \r\n                        functions[functionName] = { bindings: functionJson.bindings, isCalledBy: [], isSignalledBy: [] };\r\n    \r\n                    } catch (err) {\r\n                        log(`>>> Failed to parse ${functionJsonFilePath}: ${err}`);\r\n                    }\r\n                }\r\n            });\r\n            await Promise.all(promises);\r\n        \r\n        return functions;\r\n    }\r\n\r\n    async readProxiesJson(projectFolder: string, log: (s: any) => void): Promise<ProxiesMap> {\r\n\r\n        const proxiesJsonPath = this.joinPath(projectFolder, 'proxies.json');\r\n        if (!(await this.pathExists(proxiesJsonPath))) {\r\n            return {};\r\n        }\r\n        \r\n        const proxiesJsonString = await this.readFile(proxiesJsonPath);\r\n        try {\r\n    \r\n            const proxies = JSON.parse(proxiesJsonString).proxies as ProxiesMap;\r\n            if (!proxies) {\r\n                return {};\r\n            }\r\n    \r\n            var notAddedToCsProjFile = false;\r\n            if (await this.isCSharpProjectAsync(projectFolder)) {\r\n    \r\n                // Also checking that proxies.json is added to .csproj file\r\n    \r\n                const csProjFile = await this.findFileRecursivelyAsync(projectFolder, '.+\\\\.csproj$', true);\r\n                const proxiesJsonEntryRegex = new RegExp(`\\\\s*=\\\\s*\"proxies.json\"\\\\s*>`);\r\n    \r\n                if (!!csProjFile && csProjFile.code && (!proxiesJsonEntryRegex.exec(csProjFile.code))) {\r\n                    \r\n                    notAddedToCsProjFile = true;\r\n                }            \r\n            }\r\n    \r\n            // Also adding filePath and lineNr\r\n            for (var proxyName in proxies) {\r\n    \r\n                const proxy = proxies[proxyName];\r\n                proxy.filePath = proxiesJsonPath;\r\n                if (notAddedToCsProjFile) {\r\n                    proxy.warningNotAddedToCsProjFile = true;\r\n                }\r\n    \r\n                const proxyNameRegex = new RegExp(`\"${proxyName}\"\\\\s*:`);\r\n                const match = proxyNameRegex.exec(proxiesJsonString);\r\n                if (!!match) {\r\n                    \r\n                    proxy.pos = match.index;\r\n                    proxy.lineNr = posToLineNr(proxiesJsonString, proxy.pos);\r\n                }\r\n            }\r\n    \r\n            return proxies;\r\n    \r\n        } catch(err) {\r\n    \r\n            log(`>>> Failed to parse ${proxiesJsonPath}: ${err}`);\r\n            return {};\r\n        }\r\n    }\r\n\r\n    async isCSharpProjectAsync(projectFolder: string): Promise<boolean> {\r\n        return (await this.readDir(projectFolder)).some(fn => {\r\n            fn = fn.toLowerCase();\r\n            return (fn.endsWith('.csproj') && fn !== 'extensions.csproj');\r\n        });\r\n    }\r\n\r\n    async isFSharpProjectAsync(projectFolder: string): Promise<boolean> {\r\n        return (await this.readDir(projectFolder)).some(fn => {\r\n            fn = fn.toLowerCase();\r\n            return fn.endsWith('.fsproj');\r\n        });\r\n    }\r\n\r\n    async isJavaProjectAsync(projectFolder: string): Promise<boolean> {\r\n\r\n        const javaFileMatch = await this.findFileRecursivelyAsync(projectFolder, `.+\\\\.java$`, false);\r\n        return !!javaFileMatch;\r\n    }\r\n\r\n    async findFileRecursivelyAsync(folder: string, fileName: string | RegExp, returnFileContents: boolean, pattern?: RegExp)\r\n        : Promise<{ filePath: string, code?: string, pos?: number, length?: number } | undefined> {\r\n\r\n        const fileNameRegex = typeof fileName === 'string' ? new RegExp(fileName, 'i') : fileName;\r\n\r\n        const subFolders: string[] = [];\r\n\r\n        for (const name of await this.readDir(folder)) {\r\n\r\n            const fullPath = this.joinPath(folder, name);\r\n            const isDirectory = await this.isDirectory(fullPath);\r\n\r\n            if (!!isDirectory) {\r\n\r\n                if (!ExcludedFolders.includes(name.toLowerCase())) {\r\n\r\n                    subFolders.push(fullPath);\r\n                }\r\n\r\n            } else if (!!fileNameRegex.exec(name)) {\r\n\r\n                if (!pattern) {\r\n                    return {\r\n                        filePath: fullPath,\r\n                        code: returnFileContents ? (await this.readFile(fullPath)) : undefined\r\n                    };\r\n                }\r\n\r\n                const code = await this.readFile(fullPath);\r\n                const match = pattern.exec(code);\r\n\r\n                if (!!match) {\r\n                    return {\r\n                        filePath: fullPath,\r\n                        code: returnFileContents ? code : undefined,\r\n                        pos: match.index,\r\n                        length: match[0].length\r\n                    };\r\n                }\r\n            }\r\n        }\r\n\r\n        // Now recursively trying subfolders. Doing this _after_ checking the current folder.\r\n        for (const subFolder of subFolders) {\r\n            \r\n            const result = await this.findFileRecursivelyAsync(subFolder, fileNameRegex, returnFileContents, pattern);\r\n            if (!!result) {\r\n                return result;\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    async * findFunctionsRecursivelyAsync(folder: string, fileNameRegex: RegExp, functionAttributeRegex: RegExp, functionNamePosInRegex: number): AsyncGenerator<any> {\r\n\r\n        for (const name of await this.readDir(folder)) {\r\n    \r\n            var fullPath = this.joinPath(folder, name);\r\n            const isDirectory = await this.isDirectory(fullPath);\r\n    \r\n            if (!!isDirectory) {\r\n    \r\n                if (ExcludedFolders.includes(name.toLowerCase())) {\r\n                    continue;\r\n                }\r\n    \r\n                for await (const file of this.findFunctionsRecursivelyAsync(fullPath, fileNameRegex, functionAttributeRegex, functionNamePosInRegex)) {\r\n    \r\n                    yield file;\r\n                }\r\n    \r\n            } else if (!!fileNameRegex.exec(name)) {\r\n    \r\n                const code = await this.readFile(fullPath);\r\n    \r\n                var match: RegExpExecArray | null;\r\n                while (!!(match = functionAttributeRegex.exec(code))) {\r\n    \r\n                    let functionName = cleanupFunctionName(match[functionNamePosInRegex]);\r\n    \r\n                    const functionAttributeEndPos = match.index + match[0].length;\r\n    \r\n                    const body = getCodeInBrackets(code, functionAttributeEndPos, '{', '}', '\\n');\r\n    \r\n                    if (body.openBracketPos >= 0 && !!body.code) {\r\n    \r\n                        yield {\r\n                            functionName,\r\n                            filePath: fullPath,\r\n                            pos: match.index,\r\n                            lineNr: posToLineNr(code, match.index),\r\n                            declarationCode: body.code.substring(0, body.openBracketPos),\r\n                            bodyCode: body.code.substring(body.openBracketPos)\r\n                        };\r\n    \r\n                    } else {\r\n    \r\n                        // Returning the rest of the file\r\n    \r\n                        yield {\r\n                            functionName,\r\n                            filePath: fullPath,\r\n                            pos: match.index,\r\n                            lineNr: posToLineNr(code, match.index),\r\n    \r\n                            declarationCode: code.substring(functionAttributeEndPos),\r\n                            bodyCode: code.substring(functionAttributeEndPos)\r\n                        };\r\n    \r\n                        break;\r\n                    }\r\n                }        \r\n            }\r\n        }\r\n    }\r\n}","import { FunctionsMap, TraverseFunctionResult } from \"./FunctionsMap\";\r\nimport { FileSystemWrapperBase } from './fileSystemWrapperBase';\r\nimport { BindingsParser, getCodeInBrackets, getEventNames, mapActivitiesToOrchestrator, posToLineNr, removeNamespace, TraversalRegexes } from \"./traverseFunctionProjectUtils\";\r\n\r\nexport abstract class FunctionProjectParser {\r\n\r\n    // Collects all function.json files in a Functions project. Also tries to supplement them with bindings\r\n    // extracted from code (if the project is .Net or Java). Also parses and organizes orchestrators/activities \r\n    // (if the project uses Durable Functions)\r\n    public static async parseFunctions(projectFolder: string, fileSystemWrapper: FileSystemWrapperBase, log: (s: any) => void)\r\n        : Promise<TraverseFunctionResult> {\r\n                \r\n        const hostJsonMatch = await fileSystemWrapper.findFileRecursivelyAsync(projectFolder, 'host.json', false);\r\n        if (!hostJsonMatch) {\r\n            throw new Error('host.json file not found under the provided project path');\r\n        }\r\n\r\n        log(`>>> Found host.json at ${hostJsonMatch.filePath}`);\r\n\r\n        const hostJsonFolder = fileSystemWrapper.dirName(hostJsonMatch.filePath);\r\n        \r\n        let parser: FunctionProjectParser;\r\n\r\n        if (await fileSystemWrapper.isCSharpProjectAsync(hostJsonFolder)) {\r\n            parser = new CSharpFunctionProjectParser(fileSystemWrapper, log);\r\n        } else if (await fileSystemWrapper.isFSharpProjectAsync(hostJsonFolder)) {\r\n            parser = new FSharpFunctionProjectParser(fileSystemWrapper, log);\r\n        } else if (await fileSystemWrapper.isJavaProjectAsync(hostJsonFolder)) {\r\n            parser = new JavaFunctionProjectParser(fileSystemWrapper, log);\r\n        } else {\r\n            parser = new FunctionProjectScriptParser(fileSystemWrapper, log);\r\n\r\n            // For script-based functions use host.json's folder as the root\r\n            projectFolder = hostJsonFolder;\r\n        }\r\n\r\n        const functions = await parser.traverseFunctions(projectFolder);\r\n        \r\n        // Also reading proxies\r\n        const proxies = await fileSystemWrapper.readProxiesJson(projectFolder, log);\r\n\r\n        return { functions, proxies, projectFolder };\r\n    }\r\n\r\n    public constructor(protected _fileSystemWrapper: FileSystemWrapperBase, protected _log: (s: any) => void) {\r\n        \r\n    }\r\n\r\n    protected abstract traverseFunctions(projectFolder: string) : Promise<FunctionsMap>;\r\n\r\n    protected abstract getFunctionsAndTheirCodesAsync(functionNames: string[], hostJsonFolder: string)\r\n        : Promise<{ name: string, code: string, filePath: string, pos: number, lineNr: number }[]>    \r\n\r\n    // Tries to match orchestrations and their activities by parsing source code\r\n    protected async mapOrchestratorsAndActivitiesAsync(functions: FunctionsMap, projectFolder: string): Promise<FunctionsMap> {\r\n\r\n        const functionNames = Object.keys(functions);\r\n        \r\n        const orchestratorNames = functionNames.filter(name => functions[name].bindings.some((b: any) => b.type === 'orchestrationTrigger'));\r\n        const orchestrators = await this.getFunctionsAndTheirCodesAsync(orchestratorNames, projectFolder);\r\n\r\n        const activityNames = Object.keys(functions).filter(name => functions[name].bindings.some((b: any) => b.type === 'activityTrigger'));\r\n        const activities = await this.getFunctionsAndTheirCodesAsync(activityNames, projectFolder);\r\n\r\n        const entityNames = functionNames.filter(name => functions[name].bindings.some((b: any) => b.type === 'entityTrigger'));\r\n        const entities = await this.getFunctionsAndTheirCodesAsync(entityNames, projectFolder);\r\n\r\n        const otherFunctionNames = functionNames.filter(name => !functions[name].bindings.some((b: any) => ['orchestrationTrigger', 'activityTrigger', 'entityTrigger'].includes(b.type)));\r\n        const otherFunctions = await this.getFunctionsAndTheirCodesAsync(otherFunctionNames, projectFolder);\r\n\r\n        for (const orch of orchestrators) {\r\n\r\n            // Trying to match this orchestrator with its calling function\r\n            const regex = TraversalRegexes.getStartNewOrchestrationRegex(orch.name);\r\n            for (const func of otherFunctions) {\r\n\r\n                // If this function seems to be calling that orchestrator\r\n                if (!!regex.exec(func.code)) {\r\n\r\n                    functions[orch.name].isCalledBy = functions[orch.name].isCalledBy ?? [];\r\n                    functions[orch.name].isCalledBy.push(func.name);\r\n                }\r\n            }\r\n\r\n            // Matching suborchestrators\r\n            for (const subOrch of orchestrators) {\r\n                if (orch.name === subOrch.name) {\r\n                    continue;\r\n                }\r\n\r\n                // If this orchestrator seems to be calling that suborchestrator\r\n                const regex = TraversalRegexes.getCallSubOrchestratorRegex(subOrch.name);\r\n                if (!!regex.exec(orch.code)) {\r\n\r\n                    // Mapping that suborchestrator to this orchestrator\r\n                    functions[subOrch.name].isCalledBy = functions[subOrch.name].isCalledBy ?? [];\r\n                    functions[subOrch.name].isCalledBy.push(orch.name);\r\n                }\r\n            }\r\n\r\n            // Mapping activities to orchestrators\r\n            mapActivitiesToOrchestrator(functions, orch, activityNames);\r\n\r\n            // Checking whether orchestrator calls itself\r\n            if (!!TraversalRegexes.continueAsNewRegex.exec(orch.code)) {\r\n                functions[orch.name].isCalledByItself = true;\r\n            }\r\n\r\n            // Trying to map event producers with their consumers\r\n            const eventNames = getEventNames(orch.code);\r\n            for (const eventName of eventNames) {\r\n                \r\n                const regex = TraversalRegexes.getRaiseEventRegex(eventName);\r\n                for (const func of otherFunctions) {\r\n\r\n                    // If this function seems to be sending that event\r\n                    if (!!regex.exec(func.code)) {\r\n                        functions[orch.name].isSignalledBy = functions[orch.name].isSignalledBy ?? [];\r\n                        functions[orch.name].isSignalledBy.push({ name: func.name, signalName: eventName });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const entity of entities) {\r\n\r\n            // Trying to match this entity with its calling function\r\n            for (const func of otherFunctions) {\r\n\r\n                // If this function seems to be calling that entity\r\n                const regex = TraversalRegexes.getSignalEntityRegex(entity.name);\r\n                if (!!regex.exec(func.code)) {\r\n                    functions[entity.name].isCalledBy = functions[entity.name].isCalledBy ?? [];\r\n                    functions[entity.name].isCalledBy.push(func.name);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Also adding file paths and code positions\r\n        for (const func of otherFunctions.concat(orchestrators).concat(activities).concat(entities)) {\r\n            functions[func.name].filePath = func.filePath;\r\n            functions[func.name].pos = func.pos;\r\n            functions[func.name].lineNr = func.lineNr;\r\n        }\r\n\r\n        return functions;\r\n    }\r\n}\r\n\r\nclass FunctionProjectScriptParser extends FunctionProjectParser {\r\n\r\n    protected async traverseFunctions(projectFolder: string): Promise<FunctionsMap>{\r\n        \r\n        let functions: FunctionsMap;\r\n\r\n        functions = await this._fileSystemWrapper.readFunctionsJson(projectFolder, this._log);\r\n\r\n        // Now enriching it with more info extracted from code\r\n        functions = await this.mapOrchestratorsAndActivitiesAsync(functions, projectFolder);\r\n\r\n        return functions;\r\n    }\r\n\r\n    protected async getFunctionsAndTheirCodesAsync(functionNames: string[], hostJsonFolder: string): Promise<{ name: string; code: string; filePath: string; pos: number; lineNr: number; }[]> {\r\n\r\n        const promises = functionNames.map(async name => {\r\n\r\n            let match = await this._fileSystemWrapper.findFileRecursivelyAsync(this._fileSystemWrapper.joinPath(hostJsonFolder, name), '(index\\\\.ts|index\\\\.js|__init__\\\\.py)$', true);\r\n            \r\n            if (!match) {\r\n                return undefined;\r\n            }\r\n    \r\n            const pos = !match.pos ? 0 : match.pos;\r\n            const lineNr = posToLineNr(match.code, pos);\r\n    \r\n            return { name, code: match.code, filePath: match.filePath, pos, lineNr };\r\n        });\r\n    \r\n        return (await Promise.all(promises)).filter(f => !!f) as any;\r\n    }\r\n}\r\n\r\nabstract class FunctionProjectCodeParser extends FunctionProjectParser {\r\n\r\n    protected async traverseFunctions(projectFolder: string): Promise<FunctionsMap>{\r\n        \r\n        let functions: FunctionsMap;\r\n\r\n        functions = await this.traverseProjectCode(projectFolder);\r\n\r\n        // Now enriching it with more info extracted from code\r\n        functions = await this.mapOrchestratorsAndActivitiesAsync(functions, projectFolder);\r\n\r\n        return functions;\r\n    }\r\n\r\n    protected abstract traverseProjectCode(projectFolder: string): Promise<FunctionsMap>;  \r\n}\r\n\r\nclass CSharpFunctionProjectParser extends FunctionProjectCodeParser {\r\n\r\n    protected async getFunctionsAndTheirCodesAsync(functionNames: string[], hostJsonFolder: string): Promise<{ name: string; code: string; filePath: string; pos: number; lineNr: number; }[]> {\r\n        \r\n        const promises = functionNames.map(async name => {\r\n\r\n            const match = await this._fileSystemWrapper.findFileRecursivelyAsync(hostJsonFolder, '.+\\\\.cs$', true, TraversalRegexes.getDotNetFunctionNameRegex(name));\r\n            \r\n            if (!match) {\r\n                return undefined;\r\n            }\r\n    \r\n            const pos = !match.pos ? 0 : match.pos;\r\n            const lineNr = posToLineNr(match.code, pos);\r\n            const code = getCodeInBrackets(match.code!, match.pos! + match.length!, '{', '}', '\\n').code;\r\n    \r\n            return { name, code, filePath: match.filePath, pos, lineNr };\r\n        });\r\n    \r\n        return (await Promise.all(promises)).filter(f => !!f) as any;\r\n    }\r\n\r\n    protected async traverseProjectCode(projectFolder: string): Promise<FunctionsMap> {\r\n\r\n        const result: any = {};\r\n\r\n        const fileNameRegex = new RegExp('.+\\\\.cs$', 'i');\r\n\r\n        for await (const func of this._fileSystemWrapper.findFunctionsRecursivelyAsync(projectFolder, fileNameRegex, BindingsParser.functionAttributeRegex, 3)) {\r\n            \r\n            const bindings = BindingsParser.tryExtractBindings(func.declarationCode);\r\n       \r\n            if ( !(\r\n                bindings.some(b => b.type === 'orchestrationTrigger') ||\r\n                bindings.some(b => b.type === 'entityTrigger') ||\r\n                bindings.some(b => b.type === 'activityTrigger')\r\n            )) {\r\n                \r\n                // Also trying to extract multiple output bindings\r\n                bindings.push(...await this.extractOutputBindings(projectFolder, func.declarationCode, fileNameRegex));\r\n            }\r\n    \r\n            result[func.functionName] = {\r\n    \r\n                filePath: func.filePath,\r\n                pos: func.pos,\r\n                lineNr: func.lineNr,\r\n    \r\n                bindings: [...bindings]\r\n            };\r\n        }\r\n    \r\n        return result;\r\n    }\r\n\r\n    private async extractOutputBindings(projectFolder: string, functionCode: string, fileNameRegex: RegExp): Promise<{ type: string, direction: string }[]> {\r\n    \r\n        const returnTypeMatch = BindingsParser.functionReturnTypeRegex.exec(functionCode);\r\n        if (!returnTypeMatch) {\r\n            return [];\r\n        }\r\n    \r\n        const returnTypeName = removeNamespace(returnTypeMatch[3]);\r\n        if (!returnTypeName) {\r\n            return [];\r\n        }\r\n    \r\n        const returnTypeDefinition = await this._fileSystemWrapper.findFileRecursivelyAsync(projectFolder, fileNameRegex, true, TraversalRegexes.getClassDefinitionRegex(returnTypeName));\r\n        if (!returnTypeDefinition) {\r\n            return [];\r\n        }\r\n    \r\n        const classBody = getCodeInBrackets(returnTypeDefinition.code!, (returnTypeDefinition.pos ?? 0) + (returnTypeDefinition.length ?? 0), '{', '}');\r\n        if (!classBody.code) {\r\n            return [];\r\n        }\r\n    \r\n        return BindingsParser.tryExtractBindings(classBody.code);\r\n    }\r\n}\r\n\r\nclass FSharpFunctionProjectParser extends FunctionProjectCodeParser {\r\n\r\n    protected async getFunctionsAndTheirCodesAsync(functionNames: string[], hostJsonFolder: string): Promise<{ name: string; code: string; filePath: string; pos: number; lineNr: number; }[]> {\r\n\r\n        const promises = functionNames.map(async name => {\r\n\r\n            const match = await this._fileSystemWrapper.findFileRecursivelyAsync(hostJsonFolder, '.+\\\\.fs$', true, TraversalRegexes.getDotNetFunctionNameRegex(name));\r\n            \r\n            if (!match) {\r\n                return undefined;\r\n            }\r\n\r\n            const code = getCodeInBrackets(match.code!, match.pos! + match.length!, '{', '}', '\\n').code;\r\n            const pos = !match.pos ? 0 : match.pos;\r\n            const lineNr = posToLineNr(match.code, pos);\r\n\r\n            return { name, code, filePath: match.filePath, pos, lineNr };\r\n        });\r\n\r\n        return (await Promise.all(promises)).filter(f => !!f) as any;\r\n    }\r\n\r\n    protected async traverseProjectCode(projectFolder: string): Promise<FunctionsMap> {\r\n\r\n        const result: any = {};\r\n\r\n        for await (const func of this._fileSystemWrapper.findFunctionsRecursivelyAsync(projectFolder, new RegExp('.+\\\\.fs$', 'i'), BindingsParser.fSharpFunctionAttributeRegex, 2)) {\r\n            \r\n            const bindings = BindingsParser.tryExtractBindings(func.declarationCode);\r\n    \r\n            result[func.functionName] = {\r\n\r\n                filePath: func.filePath,\r\n                pos: func.pos,\r\n                lineNr: func.lineNr,\r\n\r\n                bindings: [...bindings]\r\n            };\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\nclass JavaFunctionProjectParser extends FunctionProjectCodeParser {\r\n\r\n    protected async getFunctionsAndTheirCodesAsync(functionNames: string[], hostJsonFolder: string): Promise<{ name: string; code: string; filePath: string; pos: number; lineNr: number; }[]> {\r\n\r\n        const promises = functionNames.map(async name => {\r\n\r\n            const match = await this._fileSystemWrapper.findFileRecursivelyAsync(hostJsonFolder, '.+\\\\.java$', true, TraversalRegexes.getDotNetFunctionNameRegex(name));\r\n            \r\n            if (!match) {\r\n                return undefined;\r\n            }\r\n\r\n            const code = getCodeInBrackets(match.code!, match.pos! + match.length!, '{', '}', '\\n').code;\r\n            const pos = !match.pos ? 0 : match.pos;\r\n            const lineNr = posToLineNr(match.code, pos);\r\n\r\n            return { name, code, filePath: match.filePath, pos, lineNr };\r\n        });\r\n\r\n        return (await Promise.all(promises)).filter(f => !!f) as any;\r\n    }\r\n\r\n    protected async traverseProjectCode(projectFolder: string): Promise<FunctionsMap> {\r\n\r\n        const result: any = {};\r\n\r\n        for await (const func of this._fileSystemWrapper.findFunctionsRecursivelyAsync(projectFolder, new RegExp('.+\\\\.java$', 'i'), BindingsParser.javaFunctionAttributeRegex, 1)) {\r\n            \r\n            const bindings = BindingsParser.tryExtractBindings(func.declarationCode);\r\n    \r\n            result[func.functionName] = {\r\n\r\n                filePath: func.filePath,\r\n                pos: func.pos,\r\n                lineNr: func.lineNr,\r\n\r\n                bindings: [...bindings]\r\n            };\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n","import { FunctionsMap } from \"./FunctionsMap\";\r\n\r\nexport function cleanupFunctionName(name: string): string {\r\n\r\n    if (!name) {\r\n        return name;\r\n    }\r\n\r\n    const nameofMatch = new RegExp(`nameof\\\\s*\\\\(\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\)`).exec(name);\r\n    if (!!nameofMatch) {\r\n\r\n        return removeNamespace(nameofMatch[1]);\r\n    }\r\n\r\n    name = name.trim();\r\n\r\n    if (name.startsWith('\"')) {\r\n        return name.replace(/^\"/, '').replace(/\"$/, '');\r\n    }\r\n\r\n    return removeNamespace(name);\r\n}\r\n\r\nexport function removeNamespace(name: string): string {\r\n\r\n    if (!name) {\r\n        return name;\r\n    }\r\n\r\n    const dotPos = name.lastIndexOf('.');\r\n    if (dotPos >= 0) {\r\n        name = name.substring(dotPos + 1);\r\n    }\r\n\r\n    return name.trim();\r\n}\r\n\r\n// Tries to extract event names that this orchestrator is awaiting\r\nexport function getEventNames(orchestratorCode: string): string[] {\r\n\r\n    const result = [];\r\n\r\n    const regex = TraversalRegexes.waitForExternalEventRegex;\r\n    var match: RegExpExecArray | null;\r\n    while (!!(match = regex.exec(orchestratorCode))) {\r\n        result.push(match[4]);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n// Tries to match orchestrator with its activities\r\nexport function mapActivitiesToOrchestrator(functions: FunctionsMap, orch: {name: string, code: string}, activityNames: string[]): void {\r\n\r\n    for (const activityName of activityNames) {\r\n\r\n        // If this orchestrator seems to be calling this activity\r\n        const regex = TraversalRegexes.getCallActivityRegex(activityName);\r\n        if (!!regex.exec(orch.code)) {\r\n\r\n            // Then mapping this activity to this orchestrator\r\n            functions[activityName].isCalledBy = functions[activityName].isCalledBy ?? [];\r\n            functions[activityName].isCalledBy.push(orch.name);\r\n        }\r\n    }\r\n}\r\n\r\n// Primitive way of getting a line number out of symbol position\r\nexport function posToLineNr(code: string | undefined, pos: number): number {\r\n    if (!code) {\r\n        return 0;\r\n    }\r\n    const lineBreaks = code.substr(0, pos).match(/(\\r\\n|\\r|\\n)/g);\r\n    return !lineBreaks ? 1 : lineBreaks.length + 1;\r\n}\r\n\r\n// Complements regex's inability to keep up with nested brackets\r\nexport function getCodeInBrackets(str: string, startFrom: number, openingBracket: string, closingBracket: string, mustHaveSymbols: string = ''): { code: string, openBracketPos: number } {\r\n\r\n    var bracketCount = 0, openBracketPos = -1, mustHaveSymbolFound = !mustHaveSymbols;\r\n\r\n    for (var i = startFrom; i < str.length; i++) {\r\n\r\n        switch (str[i]) {\r\n            case openingBracket:\r\n\r\n                if (bracketCount <= 0) {\r\n                    openBracketPos = i;\r\n                }\r\n                bracketCount++;\r\n\r\n                break;\r\n            case closingBracket:\r\n\r\n                bracketCount--;\r\n                if (bracketCount <= 0 && mustHaveSymbolFound) {\r\n                    return { code: str.substring(startFrom, i + 1), openBracketPos: openBracketPos - startFrom };\r\n                }\r\n                \r\n                break;\r\n        }\r\n\r\n        if (bracketCount > 0 && mustHaveSymbols.includes(str[i])) {\r\n            mustHaveSymbolFound = true;\r\n        }\r\n    }\r\n    return { code: '', openBracketPos: -1 };\r\n}\r\n\r\n// Complements regex's inability to keep up with nested brackets\r\nexport function getCodeInBracketsReverse(str: string, openingBracket: string, closingBracket: string): { code: string, openBracketPos: number } {\r\n\r\n    var bracketCount = 0, closingBracketPos = 0;\r\n    \r\n    for (var i = str.length - 1; i >= 0; i--) {\r\n\r\n        switch (str[i]) {\r\n            case closingBracket:\r\n\r\n                if (bracketCount <= 0) {\r\n                    closingBracketPos = i;\r\n                }\r\n                bracketCount++;\r\n\r\n                break;\r\n            case openingBracket:\r\n\r\n                bracketCount--;\r\n                if (bracketCount <= 0 ) {\r\n                    return { code: str.substring(0, closingBracketPos + 1), openBracketPos: i };\r\n                }\r\n                \r\n                break;\r\n        }\r\n    }\r\n    return { code: '', openBracketPos: -1 };\r\n}\r\n\r\n// General-purpose regexes\r\nexport class TraversalRegexes {\r\n\r\n    static getStartNewOrchestrationRegex(orchName: string): RegExp {\r\n        return new RegExp(`(StartNew|StartNewAsync|start_new|scheduleNewOrchestrationInstance)(\\\\s*<[\\\\w\\\\.-\\\\[\\\\]\\\\<\\\\>,\\\\s]+>)?\\\\s*\\\\(\\\\s*([\"'\\`]|nameof\\\\s*\\\\(\\\\s*[\\\\w\\\\.-]*|[\\\\w\\\\s\\\\.]+\\\\.\\\\s*)${orchName}\\\\s*[\"'\\\\),]{1}`, 'i');\r\n    }\r\n\r\n    static getCallSubOrchestratorRegex(subOrchName: string): RegExp {\r\n        return new RegExp(`(CallSubOrchestrator|CallSubOrchestratorWithRetry|call_sub_orchestrator)(Async)?(\\\\s*<[\\\\w\\\\.-\\\\[\\\\]\\\\<\\\\>,\\\\s]+>)?\\\\s*\\\\(\\\\s*([\"'\\`]|nameof\\\\s*\\\\(\\\\s*[\\\\w\\\\.-]*|[\\\\w\\\\s\\\\.]+\\\\.\\\\s*)${subOrchName}\\\\s*[\"'\\\\),]{1}`, 'i');\r\n    }\r\n\r\n    static readonly continueAsNewRegex = new RegExp(`ContinueAsNew\\\\s*\\\\(`, 'i');\r\n\r\n    static getRaiseEventRegex(eventName: string): RegExp {\r\n        return new RegExp(`(RaiseEvent|raise_event)(Async)?(.|\\r|\\n)*${eventName}`, 'i');\r\n    }\r\n\r\n    static getSignalEntityRegex(entityName: string): RegExp {\r\n        return new RegExp(`${entityName}\\\\s*[\"'>]{1}`);\r\n    }\r\n\r\n    static readonly waitForExternalEventRegex = new RegExp(`(WaitForExternalEvent|wait_for_external_event)(<[\\\\s\\\\w,\\\\.-\\\\[\\\\]\\\\(\\\\)\\\\<\\\\>]+>)?\\\\s*\\\\(\\\\s*(nameof\\\\s*\\\\(\\\\s*|[\"'\\`]|[\\\\w\\\\s\\\\.]+\\\\.\\\\s*)?([\\\\s\\\\w\\\\.-]+)\\\\s*[\"'\\`\\\\),]{1}`, 'gi');\r\n\r\n    static getDotNetFunctionNameRegex(funcName: string): RegExp {\r\n        return new RegExp(`FunctionName(Attribute)?\\\\s*\\\\(\\\\s*(nameof\\\\s*\\\\(\\\\s*|[\"'\\`]|[\\\\w\\\\s\\\\.]+\\\\.\\\\s*)${funcName}\\\\s*[\"'\\`\\\\)]{1}`)\r\n    }\r\n\r\n    static getJavaFunctionNameRegex(funcName: string): RegExp {\r\n        return new RegExp(`@\\\\s*FunctionName\\\\s*\\\\([\"\\\\s\\\\w\\\\.-]*${funcName}\"?\\\\)`)\r\n    }\r\n\r\n    static getCallActivityRegex(activityName: string): RegExp {\r\n        return new RegExp(`(CallActivity|call_activity)[\\\\s\\\\w,\\\\.-<>\\\\[\\\\]\\\\(\\\\)\\\\?]*\\\\([\\\\s\\\\w\\\\.-]*[\"'\\`]?${activityName}\\\\s*[\"'\\`\\\\),]{1}`, 'i');\r\n    }\r\n\r\n    static getClassDefinitionRegex(className: string): RegExp {\r\n        return new RegExp(`class\\\\s*${className}`)\r\n    }\r\n}\r\n\r\n// In .Net not all bindings are mentioned in function.json, so we need to analyze source code to extract them\r\nexport class BindingsParser {\r\n\r\n    // Extracts additional bindings info from C#/F# source code\r\n    static tryExtractBindings(funcCode: string): {type: string, direction: string}[] {\r\n\r\n        const result: {type: string, direction: string}[] = [];\r\n\r\n        if (!funcCode) {\r\n            return result;\r\n        }\r\n\r\n        const regex = this.bindingAttributeRegex;\r\n        var match: RegExpExecArray | null;\r\n        while (!!(match = regex.exec(funcCode))) {\r\n\r\n            const isReturn = !!match[3];\r\n\r\n            let attributeName = match[4];\r\n            if (attributeName.endsWith(`Attribute`)) {\r\n                attributeName = attributeName.substring(0, attributeName.length - `Attribute`.length);\r\n            }\r\n\r\n            const attributeCodeStartIndex = match.index + match[0].length;\r\n            const attributeCode = getCodeInBrackets(funcCode, attributeCodeStartIndex, '(', ')', '').code;\r\n\r\n            this.isOutRegex.lastIndex = attributeCodeStartIndex + attributeCode.length;\r\n            const isOut = !!this.isOutRegex.exec(funcCode);\r\n\r\n            switch (attributeName) {\r\n                case 'BlobInput':\r\n                case 'BlobOutput': \r\n                case 'Blob': {\r\n                    const binding: any = {\r\n                        type: 'blob',\r\n                        direction: attributeName === 'Blob' ? (isReturn || isOut ? 'out' : 'in') : (attributeName === 'BlobOutput' ? 'out' : 'in')\r\n                    };\r\n\r\n                    const paramsMatch = this.blobParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.path = paramsMatch[1];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'BlobTrigger': {\r\n                    const binding: any = { type: 'blobTrigger' };\r\n\r\n                    const paramsMatch = this.blobParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.path = paramsMatch[1];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'TableInput':\r\n                case 'TableOutput': \r\n                case 'Table': {\r\n                    const binding: any = {\r\n                        type: 'table',\r\n                        direction: attributeName === 'Table' ? (isReturn || isOut ? 'out' : 'in') : (attributeName === 'TableOutput' ? 'out' : 'in')\r\n                    };\r\n\r\n                    const paramsMatch = this.singleParamRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.tableName = paramsMatch[2];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'CosmosDBInput': \r\n                case 'CosmosDBOutput': \r\n                case 'CosmosDB': {\r\n                    const binding: any = {\r\n                        type: 'cosmosDB',\r\n                        direction: attributeName === 'CosmosDB' ? (isReturn || isOut ? 'out' : 'in') : (attributeName === 'CosmosDBOutput' ? 'out' : 'in')\r\n                    };\r\n\r\n                    const paramsMatch = this.cosmosDbParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.databaseName = paramsMatch[1];\r\n                        binding.collectionName = paramsMatch[3];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'CosmosDBTrigger': {\r\n                    const binding: any = { type: 'cosmosDBTrigger' };\r\n\r\n                    const paramsMatch = this.singleParamRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.databaseName = paramsMatch[2];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'EventGrid': \r\n                case 'EventGridOutput': {\r\n                    const binding: any = { type: 'eventGrid', direction: 'out' };\r\n\r\n                    const paramsMatch = this.eventGridParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.topicEndpointUri = paramsMatch[1];\r\n                        binding.topicKeySetting = paramsMatch[3];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'EventGridTrigger': {\r\n                    const binding: any = { type: 'eventGridTrigger' };\r\n\r\n                    const paramsMatch = this.eventGridParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.topicEndpointUri = paramsMatch[1];\r\n                        binding.topicKeySetting = paramsMatch[3];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'EventHub': \r\n                case 'EventHubOutput': {\r\n                    const binding: any = { type: 'eventHub', direction: 'out' };\r\n\r\n                    const paramsMatch = this.eventHubParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.eventHubName = paramsMatch[1];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'EventHubTrigger': {\r\n                    const binding: any = { type: 'eventHubTrigger' };\r\n\r\n                    const paramsMatch = this.eventHubParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.eventHubName = paramsMatch[1];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'Kafka': \r\n                case 'KafkaOutput': {\r\n                    const binding: any = { type: 'kafka', direction: 'out' };\r\n\r\n                    const paramsMatch = this.singleParamRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.brokerList = paramsMatch[2];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'KafkaTrigger': {\r\n                    const binding: any = { type: 'kafkaTrigger' };\r\n\r\n                    const paramsMatch = this.singleParamRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.brokerList = paramsMatch[2];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'Queue': \r\n                case 'QueueOutput': {\r\n                    const binding: any = { type: 'queue', direction: 'out' };\r\n\r\n                    const paramsMatch = this.singleParamRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding['queueName'] = paramsMatch[2];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'QueueTrigger': {\r\n                    const binding: any = { type: 'queueTrigger' };\r\n\r\n                    const paramsMatch = this.singleParamRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding['queueName'] = paramsMatch[2];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'ServiceBus': \r\n                case 'ServiceBusOutput': {\r\n                    const binding: any = { type: 'serviceBus', direction: 'out' };\r\n\r\n                    const paramsMatch = this.singleParamRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding['queueName'] = paramsMatch[2];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'ServiceBusTrigger': \r\n                case 'ServiceBusQueueTrigger': \r\n                case 'ServiceBusTopicTrigger': {\r\n                    const binding: any = { type: 'serviceBusTrigger' };\r\n\r\n                    const paramsMatch = this.singleParamRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding['queueName'] = paramsMatch[2];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'SignalRConnectionInfo': \r\n                case 'SignalRConnectionInfoInput': {\r\n                    const binding: any = { type: 'signalRConnectionInfo', direction: 'in' };\r\n\r\n                    const paramsMatch = this.signalRConnInfoParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.hubName = paramsMatch[1];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'SignalR': \r\n                case 'SignalROutput': {\r\n                    const binding: any = { type: 'signalR', direction: 'out' };\r\n\r\n                    const paramsMatch = this.signalRParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding['hubName'] = paramsMatch[1];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'SignalRTrigger': {\r\n                    const binding: any = { type: 'signalRTrigger' };\r\n\r\n                    const paramsMatch = this.signalRParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding['hubName'] = paramsMatch[1];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'RabbitMQ': \r\n                case 'RabbitMQOutput': {\r\n                    const binding: any = { type: 'rabbitMQ', direction: 'out' };\r\n\r\n                    const paramsMatch = this.rabbitMqParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding['queueName'] = paramsMatch[1];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'RabbitMQTrigger': {\r\n                    const binding: any = { type: 'rabbitMQTrigger' };\r\n\r\n                    const paramsMatch = this.rabbitMqParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding['queueName'] = paramsMatch[1];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'SendGrid': \r\n                case 'SendGridOutput': {\r\n                    result.push({ type: 'sendGrid', direction: 'out' });\r\n                    break;\r\n                }\r\n                case 'TwilioSms': {\r\n                    result.push({ type: 'twilioSms', direction: 'out' });\r\n                    break;\r\n                }\r\n                case 'HttpTrigger': {\r\n                    const binding: any = { type: 'httpTrigger', methods: [] };\r\n\r\n                    const httpTriggerRouteMatch = this.httpTriggerRouteRegex.exec(attributeCode);\r\n                    if (!!httpTriggerRouteMatch) {\r\n                        binding.route = httpTriggerRouteMatch[1];\r\n                    }\r\n\r\n                    const lowerAttributeCode = attributeCode.toLowerCase();\r\n                    for (const httpMethod of this.httpMethods) {\r\n                        \r\n                        if (lowerAttributeCode.includes(`\"${httpMethod}\"`)) {\r\n                            \r\n                            binding.methods.push(httpMethod);\r\n                        }\r\n                    }\r\n\r\n                    result.push(binding);\r\n\r\n                    result.push({ type: 'http', direction: 'out' });\r\n\r\n                    break;\r\n                }\r\n                case 'OrchestrationTrigger':\r\n                case 'DurableOrchestrationTrigger': {\r\n                    result.push({ type: 'orchestrationTrigger', direction: 'in' });\r\n                    break;\r\n                }\r\n                case 'ActivityTrigger':\r\n                case 'DurableActivityTrigger': {\r\n                    result.push({ type: 'activityTrigger', direction: 'in' });\r\n                    break;\r\n                }\r\n                case 'EntityTrigger':\r\n                case 'DurableEntityTrigger': {\r\n                    result.push({ type: 'entityTrigger', direction: 'in' });\r\n                    break;\r\n                }\r\n                default: {\r\n                    result.push({ type: attributeName, direction: isReturn || isOut ? 'out' : 'in' });\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    static readonly bindingAttributeRegex = new RegExp(`(\\\\[|@)(<)?\\\\s*(return:)?\\\\s*(\\\\w+)`, 'g');\r\n    static readonly singleParamRegex = new RegExp(`(\"|nameof\\\\s*\\\\()?([\\\\w\\\\.-]+)`);\r\n    static readonly eventHubParamsRegex = new RegExp(`\"([^\"]+)\"`);\r\n    static readonly signalRParamsRegex = new RegExp(`\"([^\"]+)\"`);\r\n    static readonly rabbitMqParamsRegex = new RegExp(`\"([^\"]+)\"`);\r\n    static readonly blobParamsRegex = new RegExp(`\"([^\"]+)\"`);\r\n    static readonly cosmosDbParamsRegex = new RegExp(`\"([^\"]+)\"(.|\\r|\\n)+?\"([^\"]+)\"`);\r\n    static readonly signalRConnInfoParamsRegex = new RegExp(`\"([^\"]+)\"`);\r\n    static readonly eventGridParamsRegex = new RegExp(`\"([^\"]+)\"(.|\\r|\\n)+?\"([^\"]+)\"`);\r\n\r\n    static readonly isOutRegex = new RegExp(`^\\\\s*\\\\]\\\\s*(out |ICollector|IAsyncCollector).*?(,|\\\\()`, 'g');\r\n\r\n    static readonly httpMethods = [`get`, `head`, `post`, `put`, `delete`, `connect`, `options`, `trace`, `patch`];\r\n    static readonly httpTriggerRouteRegex = new RegExp(`Route\\\\s*=\\\\s*\"(.*)\"`);\r\n\r\n    static readonly functionAttributeRegex = new RegExp(`\\\\[\\\\s*Function(Name)?(Attribute)?\\\\s*\\\\(([\"\\\\w\\\\s\\\\.\\\\(\\\\)-]+)\\\\)\\\\s*\\\\]`, 'g');\r\n    static readonly functionReturnTypeRegex = new RegExp(`public\\\\s*(static\\\\s*|async\\\\s*)*(Task\\\\s*<\\\\s*)?([\\\\w\\\\.]+)`);\r\n\r\n    static readonly javaFunctionAttributeRegex = new RegExp(`@\\\\s*FunctionName\\\\s*\\\\(([\"\\\\w\\\\s\\\\.\\\\(\\\\)-]+)\\\\)`, 'g');\r\n\r\n    static readonly fSharpFunctionAttributeRegex = new RegExp(`\\\\[<\\\\s*Function(Name)?\\\\s*\\\\(([\"\\\\w\\\\s\\\\.\\\\(\\\\)-]+)\\\\)`, 'g');\r\n}\r\n","module.exports = require(\"vscode\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import * as vscode from 'vscode';\nimport { FileSystemWrapper } from './FileSystemWrapper';\n\nimport { FunctionGraphView } from './FunctionGraphView';\n\nlet graphViews: FunctionGraphView[] = [];\n\nexport async function activate(context: vscode.ExtensionContext) {\n\n\tconst fsWrapper = new FileSystemWrapper();\n\n\tcontext.subscriptions.push(\n\n\t\tvscode.commands.registerCommand('az-func-as-a-graph.ShowGraph', async (item?: vscode.Uri) => {\n\n\t\t\tif (!!item) {\n\t\t\t\t\n\t\t\t\tconst pathToHostJson = item.toString();\n\n\t\t\t\tif (pathToHostJson.toLowerCase().endsWith('host.json')) {\n\t\t\t\t\t\n\t\t\t\t\tgraphViews.push(new FunctionGraphView(context, vscode.Uri.parse(fsWrapper.dirName(pathToHostJson))));\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!vscode.workspace.workspaceFolders) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet hostJsonFound = false;\n\n\t\t\tfor (const folder of vscode.workspace.workspaceFolders) {\n\n\t\t\t\tconst hostJsonPath = vscode.Uri.joinPath(folder.uri, 'host.json').toString();\n\t\t\t\t\n\t\t\t\tif (await fsWrapper.pathExists(hostJsonPath)) {\n\t\t\t\t\t\n\t\t\t\t\tgraphViews.push(new FunctionGraphView(context, folder.uri));\n\t\t\t\t\thostJsonFound = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!hostJsonFound && !!vscode.workspace.workspaceFolders.length) {\n\n\t\t\t\t// Just trying the first workspace folder, in a hope that host.json is somewhere inside\n\t\t\t\tgraphViews.push(new FunctionGraphView(context, vscode.workspace.workspaceFolders[0].uri));\n\t\t\t}\n\t\t})\t\t\n\t);\n\n\tif (!vscode.workspace.workspaceFolders) {\n\t\treturn;\n\t}\n\n    const config = vscode.workspace.getConfiguration('az-func-as-a-graph');\n\n\tif (!config.get<boolean>('showGraphAtStartup', true)) {\n\t\treturn;\n\t}\n\n\t// Showing graphs of all Functions in the workspace\n\tfor (const folder of vscode.workspace.workspaceFolders) {\n\n\t\tconst hostJsonPath = vscode.Uri.joinPath(folder.uri, 'host.json').toString();\n\t\t\n\t\tif (await fsWrapper.pathExists(hostJsonPath)) {\n\t\t\t\n\t\t\tgraphViews.push(new FunctionGraphView(context, folder.uri));\n\t\t}\n\t}\n}\n\n// This method is called when your extension is deactivated\nexport function deactivate() {\n\n\tfor (const view of graphViews) {\n\t\t\n\t\tview.cleanup();\n\t}\n}"],"names":["FileSystemWrapper","FileSystemWrapperBase","joinPath","path1","path2","vscode","Uri","parse","toString","dirName","i","lastIndexOf","Error","substring","async","path","uri","bytes","workspace","fs","readFile","TextDecoder","decode","stat","type","FileType","Directory","readDirectory","map","f","File","err","FunctionGraphView","constructor","_context","_functionProjectUri","_webViewPanel","this","_staticsFolder","extensionUri","showWebView","cleanup","dispose","title","fsPath","panel","window","createWebviewPanel","viewType","ViewColumn","One","retainContextWhenHidden","enableScripts","localResourceRoots","fileUri","then","htmlBytes","html","fixLinksToStatics","webview","embedTheme","showErrorMessage","message","onDidReceiveMessage","request","handleMessageFromWebView","undefined","subscriptions","includes","activeColorTheme","kind","replace","webView","showInformationMessage","data","looksLikeSvg","showSaveDialog","defaultUri","file","filters","filePath","TextEncoder","encode","writeFile","_traversalResult","JSON","stringify","functionName","functionOrProxy","startsWith","proxies","substr","functions","showTextDocument","ed","pos","document","positionAt","selection","Selection","revealRange","Range","FunctionProjectParser","parseFunctions","console","log","res","postMessage","catch","originalHtml","staticsFolder","resultHtml","regex","match","exec","relativePath","localPath","newPath","asWebviewUri","endsWith","toLowerCase","ExcludedFolders","hostJsonFolder","promises","readDir","fullPath","functionJsonFilePath","isDirectory","functionJsonExists","pathExists","functionJsonString","functionJson","bindings","isCalledBy","isSignalledBy","Promise","all","projectFolder","proxiesJsonPath","proxiesJsonString","notAddedToCsProjFile","isCSharpProjectAsync","csProjFile","findFileRecursivelyAsync","proxiesJsonEntryRegex","RegExp","code","proxyName","proxy","warningNotAddedToCsProjFile","index","lineNr","posToLineNr","some","fn","folder","fileName","returnFileContents","pattern","fileNameRegex","subFolders","name","push","length","subFolder","result","functionAttributeRegex","functionNamePosInRegex","findFunctionsRecursivelyAsync","cleanupFunctionName","functionAttributeEndPos","body","getCodeInBrackets","openBracketPos","declarationCode","bodyCode","static","fileSystemWrapper","hostJsonMatch","parser","CSharpFunctionProjectParser","isFSharpProjectAsync","FSharpFunctionProjectParser","isJavaProjectAsync","JavaFunctionProjectParser","FunctionProjectScriptParser","traverseFunctions","readProxiesJson","_fileSystemWrapper","_log","functionNames","Object","keys","orchestratorNames","filter","b","orchestrators","getFunctionsAndTheirCodesAsync","activityNames","activities","entityNames","entities","otherFunctionNames","otherFunctions","orch","TraversalRegexes","getStartNewOrchestrationRegex","func","subOrch","getCallSubOrchestratorRegex","mapActivitiesToOrchestrator","continueAsNewRegex","isCalledByItself","eventNames","getEventNames","eventName","getRaiseEventRegex","signalName","entity","getSignalEntityRegex","concat","readFunctionsJson","mapOrchestratorsAndActivitiesAsync","FunctionProjectCodeParser","traverseProjectCode","getDotNetFunctionNameRegex","BindingsParser","tryExtractBindings","extractOutputBindings","functionCode","returnTypeMatch","functionReturnTypeRegex","returnTypeName","removeNamespace","returnTypeDefinition","getClassDefinitionRegex","classBody","fSharpFunctionAttributeRegex","javaFunctionAttributeRegex","dotPos","trim","str","startFrom","openingBracket","closingBracket","mustHaveSymbols","bracketCount","mustHaveSymbolFound","nameofMatch","orchestratorCode","waitForExternalEventRegex","activityName","getCallActivityRegex","lineBreaks","closingBracketPos","orchName","subOrchName","entityName","funcName","className","funcCode","bindingAttributeRegex","isReturn","attributeName","attributeCodeStartIndex","attributeCode","isOutRegex","lastIndex","isOut","binding","direction","paramsMatch","blobParamsRegex","singleParamRegex","tableName","cosmosDbParamsRegex","databaseName","collectionName","eventGridParamsRegex","topicEndpointUri","topicKeySetting","eventHubParamsRegex","eventHubName","brokerList","signalRConnInfoParamsRegex","hubName","signalRParamsRegex","rabbitMqParamsRegex","methods","httpTriggerRouteMatch","httpTriggerRouteRegex","route","lowerAttributeCode","httpMethod","httpMethods","module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","graphViews","context","fsWrapper","commands","registerCommand","item","pathToHostJson","workspaceFolders","hostJsonFound","hostJsonPath","getConfiguration","get","view"],"sourceRoot":""}