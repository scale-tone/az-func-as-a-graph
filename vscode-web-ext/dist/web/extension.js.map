{"version":3,"file":"extension.js","mappings":"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","sources":["../.././src/web/FileSystemWrapper.ts","../.././src/web/FunctionGraphView.ts","../.././src/web/core/cSharpFunctionProjectParser.ts","../.././src/web/core/fSharpFunctionProjectParser.ts","../.././src/web/core/fileSystemWrapperBase.ts","../.././src/web/core/functionProjectCodeParser.ts","../.././src/web/core/functionProjectParser.ts","../.././src/web/core/functionProjectParserBase.ts","../.././src/web/core/functionProjectScriptParser.ts","../.././src/web/core/javaFunctionProjectParser.ts","../.././src/web/core/powershellFunctionProjectParser.ts","../.././src/web/core/pythonV2FunctionProjectParser.ts","../.././src/web/core/traverseFunctionProjectUtils.ts","../../external commonjs \"vscode\"","../../webpack/bootstrap","../.././src/web/extension.ts"],"sourcesContent":["import * as vscode from 'vscode';\r\n\r\nimport { FileSystemWrapperBase } from './core/fileSystemWrapperBase';\r\n\r\nexport class FileSystemWrapper extends FileSystemWrapperBase {\r\n\r\n\tpublic joinPath(path1: string, path2: string): string {\r\n\r\n\t\treturn vscode.Uri.joinPath(vscode.Uri.parse(path1), path2).toString();\r\n\t}\r\n\r\n\tpublic dirName(path1: string): string {\r\n\r\n\t\tconst i = path1.lastIndexOf('/');\r\n\r\n\t\tif (i < 0) {\r\n\t\t\tthrow new Error(`Failed to extract parent folder name from path ${path1}. The path does not contain a separator.`);\r\n\t\t}\r\n\r\n\t\treturn path1.substring(0, i);\r\n\t}\r\n\r\n\tpublic async readFile(path: string): Promise<string> {\r\n\r\n\t\tconst uri = vscode.Uri.parse(path);\r\n\r\n\t\tconst bytes = await vscode.workspace.fs.readFile(uri);\r\n\r\n\t\treturn new TextDecoder().decode(bytes);\r\n\t}\r\n\r\n\tpublic async isDirectory(path: string): Promise<boolean> {\r\n\r\n\t\tconst uri = vscode.Uri.parse(path);\r\n\r\n\t\tconst stat = await vscode.workspace.fs.stat(uri);\r\n\r\n\t\treturn stat.type === vscode.FileType.Directory;\r\n\t}\r\n\r\n\tpublic async readDir(path: string): Promise<string[]> {\r\n\r\n\t\tconst uri = vscode.Uri.parse(path);\r\n\r\n\t\tconst files = await vscode.workspace.fs.readDirectory(uri);\r\n\r\n\t\treturn files.map(f => f[0]);\r\n\t}\r\n\r\n\tpublic async pathExists(path: string): Promise<boolean> {\r\n\r\n\t\tconst uri = vscode.Uri.parse(path);\r\n\r\n\t\ttry {\r\n\t\t\t\r\n\t\t\tconst stat = await vscode.workspace.fs.stat(uri);\r\n\r\n\t\t\treturn stat.type === vscode.FileType.File || stat.type === vscode.FileType.Directory;\r\n\r\n\t\t} catch (err) {\r\n\t\t\r\n\t\t\treturn false;\r\n\t\t}\t\t\r\n\t}\r\n}\r\n","import * as vscode from 'vscode';\r\n\r\nimport { FunctionsMap, ProxiesMap } from './core/FunctionsMap';\r\nimport { FunctionProjectParser } from './core/functionProjectParser';\r\nimport { FileSystemWrapper } from './FileSystemWrapper';\r\n\r\nexport type TraversalResult = {\r\n    functions: FunctionsMap;\r\n    proxies: ProxiesMap;\r\n};\r\n\r\n// Represents the function graph view\r\nexport class FunctionGraphView\r\n{\r\n    constructor(private _context: vscode.ExtensionContext,\r\n        private _functionProjectUri: vscode.Uri) {\r\n        \r\n        this._staticsFolder = vscode.Uri.joinPath(this._context.extensionUri, 'HtmlStatics');\r\n\r\n        this._webViewPanel = this.showWebView();\r\n    }\r\n\r\n    // Closes this web view\r\n    cleanup(): void {\r\n\r\n        if (!!this._webViewPanel) {\r\n            this._webViewPanel.dispose();\r\n        }\r\n    }\r\n\r\n    // Path to html statics\r\n    private _staticsFolder: vscode.Uri;\r\n\r\n    // Reference to the already opened WebView with the main page\r\n    private _webViewPanel: vscode.WebviewPanel | null = null;    \r\n\r\n    // Functions and proxies currently shown\r\n    private _traversalResult?: TraversalResult;\r\n\r\n    private static readonly viewType = 'az-func-as-a-graph';\r\n\r\n    // Opens a WebView with function graph page in it\r\n    private showWebView(): vscode.WebviewPanel {\r\n\r\n        const title = `Functions Graph (${this._functionProjectUri.fsPath})`;\r\n\r\n        const panel = vscode.window.createWebviewPanel(\r\n            FunctionGraphView.viewType,\r\n            title,\r\n            vscode.ViewColumn.One,\r\n            {\r\n                retainContextWhenHidden: true,\r\n                enableScripts: true,\r\n                localResourceRoots: [this._staticsFolder]\r\n            }\r\n        );\r\n\r\n        const fileUri = vscode.Uri.joinPath(this._staticsFolder, 'index.html');\r\n\r\n        vscode.workspace.fs.readFile(fileUri).then(htmlBytes => {\r\n\r\n            let html = new TextDecoder().decode(htmlBytes);\r\n\r\n            html = this.fixLinksToStatics(html, this._staticsFolder, panel.webview);\r\n            html = this.embedTheme(html);\r\n    \r\n            panel.webview.html = html;\r\n    \r\n        }, err => {\r\n\r\n            vscode.window.showErrorMessage(`az-func-as-a-graph failed. ${err.message ?? err}`);\r\n        });\r\n\r\n        // handle events from WebView\r\n        panel.webview.onDidReceiveMessage(request => this.handleMessageFromWebView(panel.webview, request), undefined, this._context.subscriptions);\r\n        \r\n        return panel;\r\n    }\r\n\r\n    // Embeds the current color theme\r\n    private embedTheme(html: string): string {\r\n\r\n        if ([2, 3].includes((vscode.window as any).activeColorTheme.kind)) {\r\n            return html.replace('<script>var ClientConfig={}</script>', '<script>var ClientConfig={\\'theme\\':\\'dark\\'}</script>');\r\n        }\r\n        return html;\r\n    }\r\n\r\n    // Does communication between code in WebView and this class\r\n    private handleMessageFromWebView(webView: vscode.Webview, request: any): void {\r\n\r\n        switch (request.kind) {\r\n\r\n            case 'ShowMessage':\r\n\r\n                vscode.window.showInformationMessage(request.data);\r\n                \r\n                return;\r\n\r\n            case 'ShowError':\r\n\r\n                vscode.window.showErrorMessage(`az-func-as-a-graph failed. ${request.data}`);\r\n                \r\n                return;\r\n            \r\n            case 'SaveAs':\r\n\r\n                // Just to be extra sure...\r\n                if (!this.looksLikeSvg(request.data)) {\r\n                    vscode.window.showErrorMessage(`Invalid data format. Save failed.`);\r\n                    return;\r\n                }\r\n                \r\n                // Saving some file to local hard drive\r\n                vscode.window.showSaveDialog({ defaultUri: vscode.Uri.file('func-map.svg'), filters: { 'SVG Images': ['svg'] } }).then(filePath => {\r\n\r\n                    if (!filePath) { \r\n                        return;\r\n                    }\r\n\r\n                    const bytes = new TextEncoder().encode(request.data);\r\n\r\n                    vscode.workspace.fs.writeFile(filePath, bytes).then(() => {\r\n\r\n                        vscode.window.showInformationMessage(`SVG image saved to ${filePath}`);\r\n\r\n                    }, err => {\r\n\r\n                        vscode.window.showErrorMessage(`Failed to save. ${err.message ?? err}`);\r\n                    });\r\n\r\n                });\r\n                return;\r\n            \r\n            case 'SaveFunctionGraphAsJson':\r\n\r\n                if (!this._traversalResult) {\r\n                    return;\r\n                }\r\n                \r\n                // Saving some file to local hard drive\r\n                vscode.window.showSaveDialog({ defaultUri: vscode.Uri.file('func-map.json'), filters: { 'JSON': ['json'] } }).then(filePath => {\r\n\r\n                    if (!filePath) { \r\n                        return;\r\n                    }\r\n\r\n                    const bytes = new TextEncoder().encode(JSON.stringify(this._traversalResult, null, 3));\r\n\r\n                    vscode.workspace.fs.writeFile(filePath, bytes).then(() => {\r\n\r\n                        vscode.window.showInformationMessage(`Diagram JSON saved to ${filePath}`);\r\n\r\n                    }, err => {\r\n\r\n                        vscode.window.showErrorMessage(`Failed to save. ${err.message ?? err}`);\r\n                    });\r\n\r\n                });\r\n                return;\r\n            \r\n            case 'GotoFunctionCode':\r\n\r\n                if (!this._traversalResult) {\r\n                    return;\r\n                }\r\n\r\n                const functionName = request.data;\r\n                var functionOrProxy: any = null;\r\n\r\n                if (functionName.startsWith('proxy.')) {\r\n            \r\n                    functionOrProxy = this._traversalResult.proxies[functionName.substr(6)];\r\n    \r\n                } else {\r\n    \r\n                    functionOrProxy = this._traversalResult.functions[functionName];\r\n                }\r\n    \r\n                vscode.window.showTextDocument(vscode.Uri.parse(functionOrProxy.filePath)).then(ed => {\r\n\r\n                    const pos = ed.document.positionAt(!!functionOrProxy.pos ? functionOrProxy.pos : 0);\r\n\r\n                    ed.selection = new vscode.Selection(pos, pos);\r\n                    ed.revealRange(new vscode.Range(pos, pos));\r\n\r\n                });\r\n\r\n                return;\r\n            \r\n            case 'Refresh':\r\n\r\n                FunctionProjectParser.parseFunctions(this._functionProjectUri.toString(), new FileSystemWrapper(), console.log).then(res => {\r\n\r\n                    console.log(`>>>>>> ${this._functionProjectUri}: ${Object.keys(res.functions).length} functions`);\r\n\r\n                    this._traversalResult = res;\r\n                    webView.postMessage(this._traversalResult);\r\n        \r\n                }).catch(err => {\r\n\r\n                    this._traversalResult = undefined;\r\n                    webView.postMessage(undefined);\r\n                    \r\n                    vscode.window.showErrorMessage(`az-func-as-a-graph failed. ${err.message ?? err}`);\r\n                });\r\n                    \r\n                return;\r\n        }\r\n    }\r\n\r\n    private fixLinksToStatics(originalHtml: string, staticsFolder: vscode.Uri, webView: vscode.Webview): string {\r\n\r\n        var resultHtml: string = originalHtml;\r\n    \r\n        const regex = / (href|src)=\"\\/([0-9a-z.\\/]+)\"/ig;\r\n        var match: RegExpExecArray | null;\r\n        while (match = regex.exec(originalHtml)) {\r\n    \r\n            const relativePath = match[2];\r\n            const localPath = vscode.Uri.joinPath(staticsFolder, relativePath)\r\n            const newPath = webView.asWebviewUri(localPath).toString();\r\n    \r\n            resultHtml = resultHtml.replace(`/${relativePath}`, newPath);\r\n        }\r\n    \r\n        return resultHtml;\r\n    }\r\n\r\n    // Validates incoming SVG, just to be extra sure...\r\n    private looksLikeSvg(data: string): boolean {\r\n        return data.startsWith('<svg') && data.endsWith('</svg>') && !data.toLowerCase().includes('<script');\r\n    }\r\n}","import { FunctionsMap } from \"./FunctionsMap\";\r\nimport { getCodeInBrackets, posToLineNr, removeNamespace } from \"./traverseFunctionProjectUtils\";\r\n\r\nimport { FunctionProjectCodeParser } from \"./functionProjectCodeParser\";\r\n\r\nexport class CSharpFunctionProjectParser extends FunctionProjectCodeParser {\r\n\r\n    protected async getFunctionsAndTheirCodesAsync(functionNames: string[], hostJsonFolder: string): Promise<{ name: string; code: string; filePath: string; pos: number; lineNr: number; }[]> {\r\n        \r\n        const promises = functionNames.map(async name => {\r\n\r\n            const match = await this._fileSystemWrapper.findFileRecursivelyAsync(hostJsonFolder, '.+\\\\.cs$', true, this.getFunctionStartRegex(name));\r\n            \r\n            if (!match) {\r\n                return undefined;\r\n            }\r\n    \r\n            const pos = !match.pos ? 0 : match.pos;\r\n            const lineNr = posToLineNr(match.code, pos);\r\n            const code = getCodeInBrackets(match.code!, match.pos! + match.length!, '{', '}', '\\n').code;\r\n    \r\n            return { name, code, filePath: match.filePath, pos, lineNr };\r\n        });\r\n    \r\n        return (await Promise.all(promises)).filter(f => !!f) as any;\r\n    }\r\n\r\n    protected async traverseProjectCode(projectFolder: string): Promise<FunctionsMap> {\r\n\r\n        const result: any = {};\r\n\r\n        const fileNameRegex = new RegExp('.+\\\\.cs$', 'i');\r\n\r\n        for await (const func of this._fileSystemWrapper.findFunctionsRecursivelyAsync(projectFolder, fileNameRegex, this.getFunctionAttributeRegex())) {\r\n            \r\n            const bindings = this.tryExtractBindings(func.declarationCode);\r\n       \r\n            if ( !(\r\n                bindings.some(b => b.type === 'orchestrationTrigger') ||\r\n                bindings.some(b => b.type === 'entityTrigger') ||\r\n                bindings.some(b => b.type === 'activityTrigger')\r\n            )) {\r\n                \r\n                // Also trying to extract multiple output bindings\r\n                bindings.push(...await this.extractOutputBindings(projectFolder, func.declarationCode, fileNameRegex));\r\n            }\r\n    \r\n            result[func.functionName] = {\r\n    \r\n                filePath: func.filePath,\r\n                pos: func.pos,\r\n                lineNr: func.lineNr,\r\n    \r\n                bindings: [...bindings]\r\n            };\r\n        }\r\n    \r\n        return result;\r\n    }\r\n\r\n    private async extractOutputBindings(projectFolder: string, functionCode: string, fileNameRegex: RegExp): Promise<{ type: string, direction: string }[]> {\r\n    \r\n        const returnTypeMatch = this.functionReturnTypeRegex.exec(functionCode);\r\n        if (!returnTypeMatch) {\r\n            return [];\r\n        }\r\n    \r\n        const returnTypeName = removeNamespace(returnTypeMatch[3]);\r\n        if (!returnTypeName) {\r\n            return [];\r\n        }\r\n    \r\n        const returnTypeDefinition = await this._fileSystemWrapper.findFileRecursivelyAsync(projectFolder, fileNameRegex, true, this.getClassDefinitionRegex(returnTypeName));\r\n        if (!returnTypeDefinition) {\r\n            return [];\r\n        }\r\n    \r\n        const classBody = getCodeInBrackets(returnTypeDefinition.code!, (returnTypeDefinition.pos ?? 0) + (returnTypeDefinition.length ?? 0), '{', '}');\r\n        if (!classBody.code) {\r\n            return [];\r\n        }\r\n    \r\n        return this.tryExtractBindings(classBody.code);\r\n    }\r\n}\r\n","import { FunctionsMap } from \"./FunctionsMap\";\r\nimport { getCodeInBrackets, posToLineNr } from \"./traverseFunctionProjectUtils\";\r\n\r\nimport { RegExAndPos } from \"./fileSystemWrapperBase\";\r\nimport { FunctionProjectCodeParser } from \"./functionProjectCodeParser\";\r\n\r\nexport class FSharpFunctionProjectParser extends FunctionProjectCodeParser {\r\n\r\n    protected async getFunctionsAndTheirCodesAsync(functionNames: string[], hostJsonFolder: string): Promise<{ name: string; code: string; filePath: string; pos: number; lineNr: number; }[]> {\r\n\r\n        const promises = functionNames.map(async name => {\r\n\r\n            const match = await this._fileSystemWrapper.findFileRecursivelyAsync(hostJsonFolder, '.+\\\\.fs$', true, this.getFunctionStartRegex(name));\r\n            \r\n            if (!match) {\r\n                return undefined;\r\n            }\r\n\r\n            const code = getCodeInBrackets(match.code!, match.pos! + match.length!, '{', '}', '\\n').code;\r\n            const pos = !match.pos ? 0 : match.pos;\r\n            const lineNr = posToLineNr(match.code, pos);\r\n\r\n            return { name, code, filePath: match.filePath, pos, lineNr };\r\n        });\r\n\r\n        return (await Promise.all(promises)).filter(f => !!f) as any;\r\n    }\r\n\r\n    protected async traverseProjectCode(projectFolder: string): Promise<FunctionsMap> {\r\n\r\n        const result: any = {};\r\n\r\n        for await (const func of this._fileSystemWrapper.findFunctionsRecursivelyAsync(projectFolder, new RegExp('.+\\\\.fs$', 'i'), this.getFunctionAttributeRegex())) {\r\n            \r\n            const bindings = this.tryExtractBindings(func.declarationCode);\r\n    \r\n            result[func.functionName] = {\r\n\r\n                filePath: func.filePath,\r\n                pos: func.pos,\r\n                lineNr: func.lineNr,\r\n\r\n                bindings: [...bindings]\r\n            };\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    protected getFunctionAttributeRegex(): RegExAndPos {\r\n        return {\r\n            regex: new RegExp(`\\\\[<\\\\s*Function(Name)?\\\\s*\\\\(([\"\\\\w\\\\s\\\\.\\\\(\\\\)-]+)\\\\)`, 'g'),\r\n            pos: 2\r\n        };\r\n    }\r\n}","import { cleanupFunctionName, getCodeInBrackets, posToLineNr } from './traverseFunctionProjectUtils';\r\nimport { FunctionsMap, ProxiesMap } from './FunctionsMap';\r\n\r\nconst ExcludedFolders = ['node_modules', 'target', 'bin', 'obj', '.vs', '.vscode', '.env', '.python_packages', '.git', '.github'];\r\n\r\nexport type RegExAndPos = { regex: RegExp, pos: number };\r\n\r\n// Base class for implementing filesystem wrappers\r\nexport abstract class FileSystemWrapperBase {\r\n\r\n    public abstract dirName(path1: string): string;\r\n\r\n    public abstract joinPath(path1: string, path2: string): string;\r\n\r\n    public abstract readFile(path: string): Promise<string>;\r\n\r\n    public abstract isDirectory(path: string): Promise<boolean>;\r\n\r\n    public abstract readDir(path: string): Promise<string[]>;\r\n\r\n    public abstract pathExists(path: string): Promise<boolean>;\r\n\r\n    async readFunctionsJson(hostJsonFolder: string, log: (s: any) => void): Promise<FunctionsMap> {\r\n\r\n        let functions: FunctionsMap = {};\r\n    \r\n            // Reading function.json files, in parallel\r\n            const promises = (await this.readDir(hostJsonFolder)).map(async functionName => {\r\n    \r\n                const fullPath = this.joinPath(hostJsonFolder, functionName);\r\n                const functionJsonFilePath = this.joinPath(fullPath, 'function.json');\r\n    \r\n                const isDirectory = await this.isDirectory(fullPath);\r\n                const functionJsonExists = await this.pathExists(functionJsonFilePath);\r\n    \r\n                if (isDirectory && functionJsonExists) {\r\n    \r\n                    try {\r\n                        const functionJsonString = await this.readFile(functionJsonFilePath);\r\n                        const functionJson = JSON.parse(functionJsonString);\r\n    \r\n                        functions[functionName] = { bindings: functionJson.bindings, isCalledBy: [], isSignalledBy: [] };\r\n    \r\n                    } catch (err) {\r\n                        log(`>>> Failed to parse ${functionJsonFilePath}: ${err}`);\r\n                    }\r\n                }\r\n            });\r\n            await Promise.all(promises);\r\n        \r\n        return functions;\r\n    }\r\n\r\n    async readProxiesJson(projectFolder: string, log: (s: any) => void): Promise<ProxiesMap> {\r\n\r\n        const proxiesJsonPath = this.joinPath(projectFolder, 'proxies.json');\r\n        if (!(await this.pathExists(proxiesJsonPath))) {\r\n            return {};\r\n        }\r\n        \r\n        const proxiesJsonString = await this.readFile(proxiesJsonPath);\r\n        try {\r\n    \r\n            const proxies = JSON.parse(proxiesJsonString).proxies as ProxiesMap;\r\n            if (!proxies) {\r\n                return {};\r\n            }\r\n    \r\n            var notAddedToCsProjFile = false;\r\n            if (await this.isCSharpProjectAsync(projectFolder)) {\r\n    \r\n                // Also checking that proxies.json is added to .csproj file\r\n    \r\n                const csProjFile = await this.findFileRecursivelyAsync(projectFolder, '.+\\\\.csproj$', true);\r\n                const proxiesJsonEntryRegex = new RegExp(`\\\\s*=\\\\s*\"proxies.json\"\\\\s*>`);\r\n    \r\n                if (!!csProjFile && csProjFile.code && (!proxiesJsonEntryRegex.exec(csProjFile.code))) {\r\n                    \r\n                    notAddedToCsProjFile = true;\r\n                }            \r\n            }\r\n    \r\n            // Also adding filePath and lineNr\r\n            for (var proxyName in proxies) {\r\n    \r\n                const proxy = proxies[proxyName];\r\n                proxy.filePath = proxiesJsonPath;\r\n                if (notAddedToCsProjFile) {\r\n                    proxy.warningNotAddedToCsProjFile = true;\r\n                }\r\n    \r\n                const proxyNameRegex = new RegExp(`\"${proxyName}\"\\\\s*:`);\r\n                const match = proxyNameRegex.exec(proxiesJsonString);\r\n                if (!!match) {\r\n                    \r\n                    proxy.pos = match.index;\r\n                    proxy.lineNr = posToLineNr(proxiesJsonString, proxy.pos);\r\n                }\r\n            }\r\n    \r\n            return proxies;\r\n    \r\n        } catch(err) {\r\n    \r\n            log(`>>> Failed to parse ${proxiesJsonPath}: ${err}`);\r\n            return {};\r\n        }\r\n    }\r\n\r\n    async isCSharpProjectAsync(projectFolder: string): Promise<boolean> {\r\n        return (await this.readDir(projectFolder)).some(fn => {\r\n            fn = fn.toLowerCase();\r\n            return (fn.endsWith('.csproj') && fn !== 'extensions.csproj');\r\n        });\r\n    }\r\n\r\n    async isFSharpProjectAsync(projectFolder: string): Promise<boolean> {\r\n        return (await this.readDir(projectFolder)).some(fn => {\r\n            fn = fn.toLowerCase();\r\n            return fn.endsWith('.fsproj');\r\n        });\r\n    }\r\n\r\n    async isJavaProjectAsync(projectFolder: string): Promise<boolean> {\r\n\r\n        const javaFileMatch = await this.findFileRecursivelyAsync(projectFolder, `.+\\\\.java$`, false);\r\n        return !!javaFileMatch;\r\n    }\r\n\r\n    async isPowershellProjectAsync(projectFolder: string): Promise<boolean> {\r\n\r\n        const firstFunctionJsonFile = await this.findFileRecursivelyAsync(projectFolder, `function.json`, false);\r\n\r\n        if (!firstFunctionJsonFile || !firstFunctionJsonFile.filePath) {\r\n            return false;\r\n        }\r\n\r\n        const psFileMatch = await this.findFileRecursivelyAsync(this.dirName(firstFunctionJsonFile.filePath), `.+\\\\.ps1$`, false);\r\n\r\n        return !!psFileMatch;\r\n    }\r\n\r\n    async isPythonV2ProjectAsync(projectFolder: string): Promise<boolean> {\r\n\r\n        const pyFileMatch = await this.findFileRecursivelyAsync(projectFolder, `.+\\\\.py$`, false);\r\n        const functionJsonFileMatch = await this.findFileRecursivelyAsync(projectFolder, `function.json`, false);\r\n\r\n        return !!pyFileMatch && !functionJsonFileMatch;\r\n    }\r\n\r\n    async findFileRecursivelyAsync(folder: string, fileName: string | RegExp, returnFileContents: boolean, pattern?: RegExp)\r\n        : Promise<{ filePath: string, code?: string, pos?: number, length?: number } | undefined> {\r\n\r\n        const fileNameRegex = typeof fileName === 'string' ? new RegExp(fileName, 'i') : fileName;\r\n\r\n        const subFolders: string[] = [];\r\n\r\n        for (const name of await this.readDir(folder)) {\r\n\r\n            const fullPath = this.joinPath(folder, name);\r\n            const isDirectory = await this.isDirectory(fullPath);\r\n\r\n            if (!!isDirectory) {\r\n\r\n                if (!ExcludedFolders.includes(name.toLowerCase())) {\r\n\r\n                    subFolders.push(fullPath);\r\n                }\r\n\r\n            } else if (!!fileNameRegex.exec(name)) {\r\n\r\n                if (!pattern) {\r\n                    return {\r\n                        filePath: fullPath,\r\n                        code: returnFileContents ? (await this.readFile(fullPath)) : undefined\r\n                    };\r\n                }\r\n\r\n                const code = await this.readFile(fullPath);\r\n                const match = pattern.exec(code);\r\n\r\n                if (!!match) {\r\n                    return {\r\n                        filePath: fullPath,\r\n                        code: returnFileContents ? code : undefined,\r\n                        pos: match.index,\r\n                        length: match[0].length\r\n                    };\r\n                }\r\n            }\r\n        }\r\n\r\n        // Now recursively trying subfolders. Doing this _after_ checking the current folder.\r\n        for (const subFolder of subFolders) {\r\n            \r\n            const result = await this.findFileRecursivelyAsync(subFolder, fileNameRegex, returnFileContents, pattern);\r\n            if (!!result) {\r\n                return result;\r\n            }\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    async * findFilesRecursivelyAsync(folder: string, fileNameRegex: RegExp): AsyncGenerator<any> {\r\n\r\n        for (const name of await this.readDir(folder)) {\r\n    \r\n            var fullPath = this.joinPath(folder, name);\r\n            const isDirectory = await this.isDirectory(fullPath);\r\n    \r\n            if (!!isDirectory) {\r\n    \r\n                if (ExcludedFolders.includes(name.toLowerCase())) {\r\n                    continue;\r\n                }\r\n    \r\n                for await (const path of this.findFilesRecursivelyAsync(fullPath, fileNameRegex)) {\r\n    \r\n                    yield path;\r\n                }\r\n    \r\n            } else if (!!fileNameRegex.exec(name)) {\r\n    \r\n                yield fullPath;\r\n            }\r\n        }\r\n    }\r\n\r\n    async * findFunctionsRecursivelyAsync(folder: string, fileNameRegex: RegExp, functionAttributeRegex: RegExAndPos): AsyncGenerator<any> {\r\n\r\n        for await (const fullPath of this.findFilesRecursivelyAsync(folder, fileNameRegex)) {\r\n\r\n            const code = await this.readFile(fullPath);\r\n\r\n            var match: RegExpExecArray | null;\r\n            while (!!(match = functionAttributeRegex.regex.exec(code))) {\r\n\r\n                let functionName = cleanupFunctionName(match[functionAttributeRegex.pos]);\r\n\r\n                const functionAttributeEndPos = match.index + match[0].length;\r\n\r\n                const body = getCodeInBrackets(code, functionAttributeEndPos, '{', '}', '\\n');\r\n\r\n                if (body.openBracketPos >= 0 && !!body.code) {\r\n\r\n                    yield {\r\n                        functionName,\r\n                        filePath: fullPath,\r\n                        pos: match.index,\r\n                        lineNr: posToLineNr(code, match.index),\r\n                        declarationCode: body.code.substring(0, body.openBracketPos),\r\n                        bodyCode: body.code.substring(body.openBracketPos)\r\n                    };\r\n\r\n                } else {\r\n\r\n                    // Returning the rest of the file\r\n\r\n                    yield {\r\n                        functionName,\r\n                        filePath: fullPath,\r\n                        pos: match.index,\r\n                        lineNr: posToLineNr(code, match.index),\r\n\r\n                        declarationCode: code.substring(functionAttributeEndPos),\r\n                        bodyCode: code.substring(functionAttributeEndPos)\r\n                    };\r\n\r\n                    break;\r\n                }\r\n            }        \r\n        }\r\n    }\r\n}","import { FunctionsMap } from \"./FunctionsMap\";\r\n\r\nimport { FunctionProjectParserBase } from './functionProjectParserBase';\r\nimport { RegExAndPos } from \"./fileSystemWrapperBase\";\r\n\r\nexport abstract class FunctionProjectCodeParser extends FunctionProjectParserBase {\r\n\r\n    public async traverseFunctions(projectFolder: string): Promise<FunctionsMap>{\r\n        \r\n        let functions: FunctionsMap;\r\n\r\n        functions = await this.traverseProjectCode(projectFolder);\r\n\r\n        // Now enriching it with more info extracted from code\r\n        functions = await this.mapOrchestratorsAndActivitiesAsync(functions, projectFolder);\r\n\r\n        return functions;\r\n    }\r\n\r\n    protected abstract traverseProjectCode(projectFolder: string): Promise<FunctionsMap>;\r\n\r\n    protected getFunctionStartRegex(funcName: string): RegExp {\r\n        return new RegExp(`Function(Name)?(Attribute)?\\\\s*\\\\(\\\\s*(nameof\\\\s*\\\\(\\\\s*|[\"'\\`]|[\\\\w\\\\s\\\\.]+\\\\.\\\\s*)${funcName}\\\\s*[\"'\\`\\\\)]{1}`)\r\n    }\r\n\r\n    protected getFunctionAttributeRegex(): RegExAndPos {\r\n        return {\r\n            regex: new RegExp(`\\\\[\\\\s*Function(Name)?(Attribute)?\\\\s*\\\\(([\"\\\\w\\\\s\\\\.\\\\(\\\\)-]+)\\\\)\\\\s*\\\\]`, 'g'),\r\n            pos: 3\r\n        };\r\n    }\r\n}\r\n","import { TraverseFunctionResult } from \"./FunctionsMap\";\r\nimport { FileSystemWrapperBase } from './fileSystemWrapperBase';\r\n\r\nimport { FunctionProjectParserBase } from './functionProjectParserBase';\r\nimport { FunctionProjectScriptParser } from './functionProjectScriptParser';\r\nimport { CSharpFunctionProjectParser } from './cSharpFunctionProjectParser';\r\nimport { FSharpFunctionProjectParser } from './fSharpFunctionProjectParser';\r\nimport { JavaFunctionProjectParser } from './javaFunctionProjectParser';\r\nimport { PowershellFunctionProjectParser } from './powershellFunctionProjectParser';\r\nimport { PythonV2FunctionProjectParser } from './pythonV2FunctionProjectParser';\r\n\r\n// Parses Azure Functions projects to produce Functions map (list of all Functions, their bindings and connections to other Functions)\r\nexport abstract class FunctionProjectParser {\r\n\r\n    // Collects all function.json files in a Functions project. Also tries to supplement them with bindings\r\n    // extracted from code (if the project is .Net or Java). Also parses and organizes orchestrators/activities \r\n    // (if the project uses Durable Functions)\r\n    public static async parseFunctions(projectFolder: string, fileSystemWrapper: FileSystemWrapperBase, log: (s: any) => void)\r\n        : Promise<TraverseFunctionResult> {\r\n                \r\n        const hostJsonMatch = await fileSystemWrapper.findFileRecursivelyAsync(projectFolder, 'host.json', false);\r\n        if (!hostJsonMatch) {\r\n            throw new Error('host.json file not found under the provided project path');\r\n        }\r\n\r\n        log(`>>> Found host.json at ${hostJsonMatch.filePath}`);\r\n\r\n        const hostJsonFolder = fileSystemWrapper.dirName(hostJsonMatch.filePath);\r\n        \r\n        let parser: FunctionProjectParserBase;\r\n\r\n        if (await fileSystemWrapper.isCSharpProjectAsync(hostJsonFolder)) {\r\n            parser = new CSharpFunctionProjectParser(fileSystemWrapper, log);\r\n        } else if (await fileSystemWrapper.isFSharpProjectAsync(hostJsonFolder)) {\r\n            parser = new FSharpFunctionProjectParser(fileSystemWrapper, log);\r\n        } else if (await fileSystemWrapper.isJavaProjectAsync(hostJsonFolder)) {\r\n            parser = new JavaFunctionProjectParser(fileSystemWrapper, log);\r\n        } else if (await fileSystemWrapper.isPowershellProjectAsync(hostJsonFolder)) {\r\n            parser = new PowershellFunctionProjectParser(fileSystemWrapper, log);\r\n        } else if (await fileSystemWrapper.isPythonV2ProjectAsync(hostJsonFolder)) {\r\n            parser = new PythonV2FunctionProjectParser(fileSystemWrapper, log);\r\n        } else {\r\n            parser = new FunctionProjectScriptParser(fileSystemWrapper, log);\r\n\r\n            // For script-based functions use host.json's folder as the root\r\n            projectFolder = hostJsonFolder;\r\n        }\r\n\r\n        const functions = await parser.traverseFunctions(projectFolder);\r\n        \r\n        // Also reading proxies\r\n        const proxies = await fileSystemWrapper.readProxiesJson(projectFolder, log);\r\n\r\n        return { functions, proxies, projectFolder };\r\n    }\r\n}\r\n","import { FunctionsMap } from \"./FunctionsMap\";\r\nimport { FileSystemWrapperBase, RegExAndPos } from './fileSystemWrapperBase';\r\nimport { getCodeInBrackets } from \"./traverseFunctionProjectUtils\";\r\n\r\n// Parses Azure Functions projects to produce Functions map (list of all Functions, their bindings and connections to other Functions)\r\nexport abstract class FunctionProjectParserBase {\r\n\r\n    public constructor(protected _fileSystemWrapper: FileSystemWrapperBase, protected _log: (s: any) => void) {\r\n        \r\n    }\r\n\r\n    public abstract traverseFunctions(projectFolder: string) : Promise<FunctionsMap>;\r\n\r\n    protected abstract getFunctionsAndTheirCodesAsync(functionNames: string[], hostJsonFolder: string)\r\n        : Promise<{ name: string, code: string, filePath: string, pos: number, lineNr: number }[]>    \r\n\r\n    // Tries to match orchestrations and their activities by parsing source code\r\n    protected async mapOrchestratorsAndActivitiesAsync(functions: FunctionsMap, projectFolder: string): Promise<FunctionsMap> {\r\n\r\n        const functionNames = Object.keys(functions);\r\n        \r\n        const orchestratorNames = functionNames.filter(name => functions[name].bindings.some((b: any) => b.type === 'orchestrationTrigger'));\r\n        const orchestrators = await this.getFunctionsAndTheirCodesAsync(orchestratorNames, projectFolder);\r\n\r\n        const activityNames = Object.keys(functions).filter(name => functions[name].bindings.some((b: any) => b.type === 'activityTrigger'));\r\n        const activities = await this.getFunctionsAndTheirCodesAsync(activityNames, projectFolder);\r\n\r\n        const entityNames = functionNames.filter(name => functions[name].bindings.some((b: any) => b.type === 'entityTrigger'));\r\n        const entities = await this.getFunctionsAndTheirCodesAsync(entityNames, projectFolder);\r\n\r\n        const otherFunctionNames = functionNames.filter(name => !functions[name].bindings.some((b: any) => ['orchestrationTrigger', 'activityTrigger', 'entityTrigger'].includes(b.type)));\r\n        const otherFunctions = await this.getFunctionsAndTheirCodesAsync(otherFunctionNames, projectFolder);\r\n\r\n        for (const orch of orchestrators) {\r\n\r\n            // Trying to match this orchestrator with its calling function\r\n            const regex = this.getStartNewOrchestrationRegex(orch.name);\r\n            for (const func of otherFunctions) {\r\n\r\n                // If this function seems to be calling that orchestrator\r\n                if (!!regex.exec(func.code)) {\r\n\r\n                    functions[orch.name].isCalledBy = functions[orch.name].isCalledBy ?? [];\r\n                    functions[orch.name].isCalledBy.push(func.name);\r\n                }\r\n            }\r\n\r\n            // Matching suborchestrators\r\n            for (const subOrch of orchestrators) {\r\n                if (orch.name === subOrch.name) {\r\n                    continue;\r\n                }\r\n\r\n                // If this orchestrator seems to be calling that suborchestrator\r\n                const regex = this.getCallSubOrchestratorRegex(subOrch.name);\r\n                if (!!regex.exec(orch.code)) {\r\n\r\n                    // Mapping that suborchestrator to this orchestrator\r\n                    functions[subOrch.name].isCalledBy = functions[subOrch.name].isCalledBy ?? [];\r\n                    functions[subOrch.name].isCalledBy.push(orch.name);\r\n                }\r\n            }\r\n\r\n            // Mapping activities to orchestrators\r\n            this.mapActivitiesToOrchestrator(functions, orch, activityNames);\r\n\r\n            // Checking whether orchestrator calls itself\r\n            if (!!this.getContinueAsNewRegex().exec(orch.code)) {\r\n                functions[orch.name].isCalledByItself = true;\r\n            }\r\n\r\n            // Trying to map event producers with their consumers\r\n            const eventNames = this.getEventNames(orch.code);\r\n            for (const eventName of eventNames) {\r\n                \r\n                const regex = this.getRaiseEventRegex(eventName);\r\n                for (const func of otherFunctions) {\r\n\r\n                    // If this function seems to be sending that event\r\n                    if (!!regex.exec(func.code)) {\r\n                        functions[orch.name].isSignalledBy = functions[orch.name].isSignalledBy ?? [];\r\n                        functions[orch.name].isSignalledBy.push({ name: func.name, signalName: eventName });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const entity of entities) {\r\n\r\n            // Trying to match this entity with its calling function\r\n            for (const func of otherFunctions) {\r\n\r\n                // If this function seems to be calling that entity\r\n                const regex = this.getSignalEntityRegex(entity.name);\r\n                if (!!regex.exec(func.code)) {\r\n                    functions[entity.name].isCalledBy = functions[entity.name].isCalledBy ?? [];\r\n                    functions[entity.name].isCalledBy.push(func.name);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Also adding file paths and code positions\r\n        for (const func of otherFunctions.concat(orchestrators).concat(activities).concat(entities)) {\r\n            functions[func.name].filePath = func.filePath;\r\n            functions[func.name].pos = func.pos;\r\n            functions[func.name].lineNr = func.lineNr;\r\n        }\r\n\r\n        return functions;\r\n    }\r\n\r\n    // Tries to extract event names that this orchestrator is awaiting\r\n    protected getEventNames(orchestratorCode: string): string[] {\r\n\r\n        const result = [];\r\n\r\n        const regex = this.getWaitForExternalEventRegex();\r\n        var match: RegExpExecArray | null;\r\n        while (!!(match = regex.regex.exec(orchestratorCode))) {\r\n            result.push(match[regex.pos]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // Tries to match orchestrator with its activities\r\n    protected mapActivitiesToOrchestrator(functions: FunctionsMap, orch: {name: string, code: string}, activityNames: string[]): void {\r\n\r\n        for (const activityName of activityNames) {\r\n\r\n            // If this orchestrator seems to be calling this activity\r\n            const regex = this.getCallActivityRegex(activityName);\r\n            if (!!regex.exec(orch.code)) {\r\n\r\n                // Then mapping this activity to this orchestrator\r\n                functions[activityName].isCalledBy = functions[activityName].isCalledBy ?? [];\r\n                functions[activityName].isCalledBy.push(orch.name);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Extracts additional bindings info from C#/F# source code\r\n    protected tryExtractBindings(funcCode: string): {type: string, direction: string}[] {\r\n\r\n        const result: {type: string, direction: string}[] = [];\r\n\r\n        if (!funcCode) {\r\n            return result;\r\n        }\r\n\r\n        const regex = this.getBindingAttributeRegex();\r\n        let match: RegExpExecArray | null;\r\n        while (!!(match = regex.regex.exec(funcCode))) {\r\n\r\n            const isReturn = match[regex.pos - 1] === 'return:';\r\n\r\n            let attributeName = match[regex.pos];\r\n            if (attributeName.endsWith(`Attribute`)) {\r\n                attributeName = attributeName.substring(0, attributeName.length - `Attribute`.length);\r\n            }\r\n\r\n            const attributeCodeStartIndex = match.index + match[0].length;\r\n            const attributeCode = getCodeInBrackets(funcCode, attributeCodeStartIndex, '(', ')', '').code;\r\n\r\n            this.isOutRegex.lastIndex = attributeCodeStartIndex + attributeCode.length;\r\n            const isOut = !!this.isOutRegex.exec(funcCode);\r\n\r\n            switch (attributeName) {\r\n                case 'read_blob':\r\n                case 'blob_input':\r\n                case 'blob_output':\r\n                case 'BlobInput':\r\n                case 'BlobOutput': \r\n                case 'Blob': {\r\n                    const binding: any = {\r\n                        type: 'blob',\r\n                        direction: attributeName === 'Blob' ? (isReturn || isOut ? 'out' : 'in') : (attributeName.toLowerCase().endsWith('output') ? 'out' : 'in')\r\n                    };\r\n\r\n                    const paramsMatch = this.blobParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.path = paramsMatch[1];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'blob_trigger':\r\n                case 'BlobTrigger': {\r\n                    const binding: any = { type: 'blobTrigger' };\r\n\r\n                    const paramsMatch = this.blobParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.path = paramsMatch[1];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'table_input':\r\n                case 'table_output':\r\n                case 'TableInput':\r\n                case 'TableOutput': \r\n                case 'Table': {\r\n                    const binding: any = {\r\n                        type: 'table',\r\n                        direction: attributeName === 'Table' ? (isReturn || isOut ? 'out' : 'in') : (attributeName.toLowerCase().endsWith('output') ? 'out' : 'in')\r\n                    };\r\n\r\n                    const paramsMatch = this.singleParamRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.tableName = paramsMatch[2];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'CosmosDBInput': \r\n                case 'CosmosDBOutput': \r\n                case 'CosmosDB': {\r\n                    const binding: any = {\r\n                        type: 'cosmosDB',\r\n                        direction: attributeName === 'CosmosDB' ? (isReturn || isOut ? 'out' : 'in') : (attributeName.toLowerCase().endsWith('output') ? 'out' : 'in')\r\n                    };\r\n\r\n                    const paramsMatch = this.cosmosDbParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.databaseName = paramsMatch[1];\r\n                        binding.collectionName = paramsMatch[3];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'cosmos_db_trigger':\r\n                case 'CosmosDBTrigger': {\r\n                    const binding: any = { type: 'cosmosDBTrigger' };\r\n\r\n                    const paramsMatch = this.singleParamRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.databaseName = paramsMatch[2];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'event_grid_output': \r\n                case 'EventGrid': \r\n                case 'EventGridOutput': {\r\n                    const binding: any = { type: 'eventGrid', direction: 'out' };\r\n\r\n                    const paramsMatch = this.eventGridParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.topicEndpointUri = paramsMatch[1];\r\n                        binding.topicKeySetting = paramsMatch[3];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'EventGridTrigger': {\r\n                    const binding: any = { type: 'eventGridTrigger' };\r\n\r\n                    const paramsMatch = this.eventGridParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.topicEndpointUri = paramsMatch[1];\r\n                        binding.topicKeySetting = paramsMatch[3];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'event_hub_output':\r\n                case 'EventHub': \r\n                case 'EventHubOutput': {\r\n                    const binding: any = { type: 'eventHub', direction: 'out' };\r\n\r\n                    const paramsMatch = this.eventHubParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.eventHubName = paramsMatch[1];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'event_hub_message_trigger':\r\n                case 'EventHubTrigger': {\r\n                    const binding: any = { type: 'eventHubTrigger' };\r\n\r\n                    const paramsMatch = this.eventHubParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.eventHubName = paramsMatch[1];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'Kafka': \r\n                case 'KafkaOutput': {\r\n                    const binding: any = { type: 'kafka', direction: 'out' };\r\n\r\n                    const paramsMatch = this.singleParamRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.brokerList = paramsMatch[2];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'KafkaTrigger': {\r\n                    const binding: any = { type: 'kafkaTrigger' };\r\n\r\n                    const paramsMatch = this.singleParamRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.brokerList = paramsMatch[2];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'queue_output':\r\n                case 'Queue': \r\n                case 'QueueOutput': {\r\n                    const binding: any = { type: 'queue', direction: 'out' };\r\n\r\n                    const paramsMatch = this.singleParamRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding['queueName'] = paramsMatch[2];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'queue_trigger':\r\n                case 'QueueTrigger': {\r\n                    const binding: any = { type: 'queueTrigger' };\r\n\r\n                    const paramsMatch = this.singleParamRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding['queueName'] = paramsMatch[2];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'service_bus_queue_output':\r\n                case 'service_bus_topic_output':\r\n                case 'ServiceBus': \r\n                case 'ServiceBusOutput': {\r\n                    const binding: any = { type: 'serviceBus', direction: 'out' };\r\n\r\n                    const paramsMatch = this.singleParamRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding['queueName'] = paramsMatch[2];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'service_bus_queue_trigger':\r\n                case 'service_bus_topic_trigger':\r\n                case 'ServiceBusTrigger': \r\n                case 'ServiceBusQueueTrigger': \r\n                case 'ServiceBusTopicTrigger': {\r\n                    const binding: any = { type: 'serviceBusTrigger' };\r\n\r\n                    const paramsMatch = this.singleParamRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding['queueName'] = paramsMatch[2];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'SignalRConnectionInfo': \r\n                case 'SignalRConnectionInfoInput': {\r\n                    const binding: any = { type: 'signalRConnectionInfo', direction: 'in' };\r\n\r\n                    const paramsMatch = this.signalRConnInfoParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding.hubName = paramsMatch[1];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'SignalR': \r\n                case 'SignalROutput': {\r\n                    const binding: any = { type: 'signalR', direction: 'out' };\r\n\r\n                    const paramsMatch = this.signalRParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding['hubName'] = paramsMatch[1];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'SignalRTrigger': {\r\n                    const binding: any = { type: 'signalRTrigger' };\r\n\r\n                    const paramsMatch = this.signalRParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding['hubName'] = paramsMatch[1];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'RabbitMQ': \r\n                case 'RabbitMQOutput': {\r\n                    const binding: any = { type: 'rabbitMQ', direction: 'out' };\r\n\r\n                    const paramsMatch = this.rabbitMqParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding['queueName'] = paramsMatch[1];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'RabbitMQTrigger': {\r\n                    const binding: any = { type: 'rabbitMQTrigger' };\r\n\r\n                    const paramsMatch = this.rabbitMqParamsRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding['queueName'] = paramsMatch[1];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'SendGrid': \r\n                case 'SendGridOutput': {\r\n                    result.push({ type: 'sendGrid', direction: 'out' });\r\n                    break;\r\n                }\r\n                case 'TwilioSms': {\r\n                    result.push({ type: 'twilioSms', direction: 'out' });\r\n                    break;\r\n                }\r\n                case 'route':\r\n                case 'HttpTrigger': {\r\n                    const binding: any = { type: 'httpTrigger', methods: [] };\r\n\r\n                    const httpTriggerRouteMatch = this.httpTriggerRouteRegex.exec(attributeCode);\r\n                    if (!!httpTriggerRouteMatch) {\r\n                        binding.route = httpTriggerRouteMatch[1];\r\n                    }\r\n\r\n                    const lowerAttributeCode = attributeCode.toLowerCase();\r\n                    for (const httpMethod of this.httpMethods) {\r\n                        \r\n                        if (lowerAttributeCode.includes(`\"${httpMethod}\"`)) {\r\n                            \r\n                            binding.methods.push(httpMethod);\r\n                        }\r\n                    }\r\n\r\n                    if (/level.anonymous/i.exec(attributeCode)) {\r\n                        \r\n                        binding.authLevel = 'anonymous';\r\n                    }\r\n\r\n                    result.push(binding);\r\n\r\n                    result.push({ type: 'http', direction: 'out' });\r\n\r\n                    break;\r\n                }\r\n                case 'orchestration_trigger':\r\n                case 'OrchestrationTrigger':\r\n                case 'DurableOrchestrationTrigger': {\r\n                    result.push({ type: 'orchestrationTrigger', direction: 'in' });\r\n                    break;\r\n                }\r\n                case 'activity_trigger':\r\n                case 'ActivityTrigger':\r\n                case 'DurableActivityTrigger': {\r\n                    result.push({ type: 'activityTrigger', direction: 'in' });\r\n                    break;\r\n                }\r\n                case 'EntityTrigger':\r\n                case 'DurableEntityTrigger': {\r\n                    result.push({ type: 'entityTrigger', direction: 'in' });\r\n                    break;\r\n                }\r\n                case 'schedule':\r\n                case 'TimerTrigger': {\r\n                    const binding: any = { type: 'timerTrigger' };\r\n\r\n                    const paramsMatch = this.singleParamRegex.exec(attributeCode);\r\n                    if (!!paramsMatch) {\r\n                        binding['schedule'] = paramsMatch[2];\r\n                    }\r\n                    result.push(binding);\r\n\r\n                    break;\r\n                }\r\n                case 'OrchestrationClient':\r\n                case 'DurableClient':\r\n                case 'DurableClientInput': {\r\n                    result.push({ type: 'durableClient', direction: 'in' });\r\n                    break;\r\n                }                    \r\n                default: {\r\n                    // Doing nothing for now, as there are too many \"false positives\"\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    protected readonly singleParamRegex = new RegExp(`(\"|nameof\\\\s*\\\\()?([\\\\w\\\\.-]+)`);\r\n    protected readonly eventHubParamsRegex = new RegExp(`\"([^\"]+)\"`);\r\n    protected readonly signalRParamsRegex = new RegExp(`\"([^\"]+)\"`);\r\n    protected readonly rabbitMqParamsRegex = new RegExp(`\"([^\"]+)\"`);\r\n    protected readonly blobParamsRegex = new RegExp(`\"([^\"]+)\"`);\r\n    protected readonly cosmosDbParamsRegex = new RegExp(`\"([^\"]+)\"(.|\\r|\\n)+?\"([^\"]+)\"`);\r\n    protected readonly signalRConnInfoParamsRegex = new RegExp(`\"([^\"]+)\"`);\r\n    protected readonly eventGridParamsRegex = new RegExp(`\"([^\"]+)\"(.|\\r|\\n)+?\"([^\"]+)\"`);\r\n\r\n    protected readonly isOutRegex = new RegExp(`^\\\\s*\\\\]\\\\s*(out |ICollector|IAsyncCollector).*?(,|\\\\()`, 'g');\r\n\r\n    protected readonly httpMethods = [`get`, `head`, `post`, `put`, `delete`, `connect`, `options`, `trace`, `patch`];\r\n    protected readonly httpTriggerRouteRegex = new RegExp(`Route\\\\s*=\\\\s*\"(.*)\"`);\r\n\r\n    protected readonly functionReturnTypeRegex = new RegExp(`public\\\\s*(static\\\\s*|async\\\\s*)*(Task\\\\s*<\\\\s*)?([\\\\w\\\\.]+)`);\r\n\r\n\r\n    protected getBindingAttributeRegex(): RegExAndPos {\r\n        \r\n        return {\r\n            regex: new RegExp(`(\\\\[|@)(<)?\\\\s*(return:)?\\\\s*(\\\\w+)`, 'g'),\r\n            pos: 4\r\n        };\r\n    }\r\n\r\n    protected getStartNewOrchestrationRegex(orchName: string): RegExp {\r\n        return new RegExp(`(StartNew|StartNewAsync|start_new|scheduleNewOrchestrationInstance|scheduleNewOrchestrationInstanceAsync)(\\\\s*<[\\\\w\\\\.-\\\\[\\\\]\\\\<\\\\>,\\\\s]+>)?\\\\s*\\\\(\\\\s*([\"'\\`]|nameof\\\\s*\\\\(\\\\s*[\\\\w\\\\.-]*|[\\\\w\\\\s\\\\.]+\\\\.\\\\s*)${orchName}\\\\s*[\"'\\\\),]{1}`, 'i');\r\n    }\r\n\r\n    protected getCallSubOrchestratorRegex(subOrchName: string): RegExp {\r\n        return new RegExp(`(CallSubOrchestrator|CallSubOrchestratorWithRetry|call_sub_orchestrator)(Async)?(\\\\s*<[\\\\w\\\\.-\\\\[\\\\]\\\\<\\\\>,\\\\s]+>)?\\\\s*\\\\(\\\\s*([\"'\\`]|nameof\\\\s*\\\\(\\\\s*[\\\\w\\\\.-]*|[\\\\w\\\\s\\\\.]+\\\\.\\\\s*)${subOrchName}\\\\s*[\"'\\\\),]{1}`, 'i');\r\n    }\r\n\r\n    protected getContinueAsNewRegex(): RegExp {\r\n        return new RegExp(`ContinueAsNew\\\\s*\\\\(`, 'i');\r\n    }\r\n\r\n    protected getRaiseEventRegex(eventName: string): RegExp {\r\n        return new RegExp(`(RaiseEvent|raise_event)(Async)?(.|\\r|\\n)*${eventName}`, 'i');\r\n    }\r\n\r\n    protected getSignalEntityRegex(entityName: string): RegExp {\r\n        return new RegExp(`${entityName}\\\\s*[\"'>]{1}`);\r\n    }\r\n\r\n    protected getWaitForExternalEventRegex(): RegExAndPos {\r\n        return {\r\n            regex: new RegExp(`(WaitForExternalEvent|wait_for_external_event)(<[\\\\s\\\\w,\\\\.-\\\\[\\\\]\\\\(\\\\)\\\\<\\\\>]+>)?\\\\s*\\\\(\\\\s*(nameof\\\\s*\\\\(\\\\s*|[\"'\\`]|[\\\\w\\\\s\\\\.]+\\\\.\\\\s*)?([\\\\s\\\\w\\\\.-]+)\\\\s*[\"'\\`\\\\),]{1}`, 'gi'),\r\n            pos: 4\r\n        };\r\n    }\r\n\r\n    protected getCallActivityRegex(activityName: string): RegExp {\r\n        return new RegExp(`(CallActivity|call_activity)[\\\\s\\\\w,\\\\.-<>\\\\[\\\\]\\\\(\\\\)\\\\?]*\\\\([\\\\s\\\\w\\\\.-]*[\"'\\`]?${activityName}\\\\s*[\"'\\`\\\\),]{1}`, 'i');\r\n    }\r\n\r\n    protected getClassDefinitionRegex(className: string): RegExp {\r\n        return new RegExp(`class\\\\s*${className}`)\r\n    }\r\n}\r\n","import { FunctionsMap } from \"./FunctionsMap\";\r\nimport { posToLineNr } from \"./traverseFunctionProjectUtils\";\r\n\r\nimport { FunctionProjectParserBase } from './functionProjectParserBase';\r\n\r\nexport class FunctionProjectScriptParser extends FunctionProjectParserBase {\r\n\r\n    public async traverseFunctions(projectFolder: string): Promise<FunctionsMap>{\r\n        \r\n        let functions: FunctionsMap;\r\n\r\n        functions = await this._fileSystemWrapper.readFunctionsJson(projectFolder, this._log);\r\n\r\n        // Now enriching it with more info extracted from code\r\n        functions = await this.mapOrchestratorsAndActivitiesAsync(functions, projectFolder);\r\n\r\n        return functions;\r\n    }\r\n\r\n    protected async getFunctionsAndTheirCodesAsync(functionNames: string[], hostJsonFolder: string): Promise<{ name: string; code: string; filePath: string; pos: number; lineNr: number; }[]> {\r\n\r\n        const promises = functionNames.map(async name => {\r\n\r\n            let match = await this._fileSystemWrapper.findFileRecursivelyAsync(\r\n                this._fileSystemWrapper.joinPath(hostJsonFolder, name),\r\n                '(index\\\\.ts|index\\\\.js|__init__\\\\.py)$',\r\n                true);\r\n            \r\n            if (!match) {\r\n                return undefined;\r\n            }\r\n    \r\n            const pos = !match.pos ? 0 : match.pos;\r\n            const lineNr = posToLineNr(match.code, pos);\r\n    \r\n            return { name, code: match.code, filePath: match.filePath, pos, lineNr };\r\n        });\r\n    \r\n        return (await Promise.all(promises)).filter(f => !!f) as any;\r\n    }\r\n}\r\n\r\n","import { FunctionsMap } from \"./FunctionsMap\";\r\nimport { getCodeInBrackets, posToLineNr } from \"./traverseFunctionProjectUtils\";\r\n\r\nimport { RegExAndPos } from \"./fileSystemWrapperBase\";\r\nimport { FunctionProjectCodeParser } from \"./functionProjectCodeParser\";\r\n\r\nexport class JavaFunctionProjectParser extends FunctionProjectCodeParser {\r\n\r\n    protected async getFunctionsAndTheirCodesAsync(functionNames: string[], hostJsonFolder: string): Promise<{ name: string; code: string; filePath: string; pos: number; lineNr: number; }[]> {\r\n\r\n        const promises = functionNames.map(async name => {\r\n\r\n            const match = await this._fileSystemWrapper.findFileRecursivelyAsync(hostJsonFolder, '.+\\\\.java$', true, this.getFunctionStartRegex(name));\r\n            \r\n            if (!match) {\r\n                return undefined;\r\n            }\r\n\r\n            const code = getCodeInBrackets(match.code!, match.pos! + match.length!, '{', '}', '\\n').code;\r\n            const pos = !match.pos ? 0 : match.pos;\r\n            const lineNr = posToLineNr(match.code, pos);\r\n\r\n            return { name, code, filePath: match.filePath, pos, lineNr };\r\n        });\r\n\r\n        return (await Promise.all(promises)).filter(f => !!f) as any;\r\n    }\r\n\r\n    protected async traverseProjectCode(projectFolder: string): Promise<FunctionsMap> {\r\n\r\n        const result: any = {};\r\n\r\n        for await (const func of this._fileSystemWrapper.findFunctionsRecursivelyAsync(projectFolder, new RegExp('.+\\\\.java$', 'i'), this.getFunctionAttributeRegex())) {\r\n            \r\n            const bindings = this.tryExtractBindings(func.declarationCode);\r\n    \r\n            result[func.functionName] = {\r\n\r\n                filePath: func.filePath,\r\n                pos: func.pos,\r\n                lineNr: func.lineNr,\r\n\r\n                bindings: [...bindings]\r\n            };\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    protected getFunctionAttributeRegex(): RegExAndPos {\r\n        return {\r\n            regex: new RegExp(`@\\\\s*FunctionName\\\\s*\\\\(([\"\\\\w\\\\s\\\\.\\\\(\\\\)-]+)\\\\)`, 'g'),\r\n            pos: 1\r\n        };\r\n    }\r\n}","import { FunctionsMap } from \"./FunctionsMap\";\r\nimport { posToLineNr } from \"./traverseFunctionProjectUtils\";\r\n\r\nimport { FunctionProjectParserBase } from './functionProjectParserBase';\r\nimport { RegExAndPos } from \"./fileSystemWrapperBase\";\r\n\r\nexport class PowershellFunctionProjectParser extends FunctionProjectParserBase {\r\n\r\n    public async traverseFunctions(projectFolder: string): Promise<FunctionsMap>{\r\n        \r\n        let functions: FunctionsMap;\r\n\r\n        functions = await this._fileSystemWrapper.readFunctionsJson(projectFolder, this._log);\r\n\r\n        // Now enriching it with more info extracted from code\r\n        functions = await this.mapOrchestratorsAndActivitiesAsync(functions, projectFolder);\r\n\r\n        return functions;\r\n    }\r\n\r\n    protected async getFunctionsAndTheirCodesAsync(functionNames: string[], hostJsonFolder: string): Promise<{ name: string; code: string; filePath: string; pos: number; lineNr: number; }[]> {\r\n\r\n        const promises = functionNames.map(async name => {\r\n\r\n            let scriptFile = 'run\\\\.ps1$';\r\n\r\n            const functionJsonMatch = await this._fileSystemWrapper.findFileRecursivelyAsync(\r\n                this._fileSystemWrapper.joinPath(hostJsonFolder, name),\r\n                'function.json$',\r\n                true\r\n            );\r\n\r\n            if (!!functionJsonMatch) {\r\n                \r\n                const functionJson = JSON.parse(functionJsonMatch.code!);\r\n\r\n                if (!!functionJson.scriptFile) {\r\n                    scriptFile = functionJson.scriptFile.replace('.', '\\\\.');\r\n                }\r\n            }\r\n\r\n            const match = await this._fileSystemWrapper.findFileRecursivelyAsync(\r\n                this._fileSystemWrapper.joinPath(hostJsonFolder, name),\r\n                scriptFile,\r\n                true\r\n            );\r\n            \r\n            if (!match) {\r\n                return undefined;\r\n            }\r\n    \r\n            const pos = !match.pos ? 0 : match.pos;\r\n            const lineNr = posToLineNr(match.code, pos);\r\n    \r\n            return { name, code: match.code, filePath: match.filePath, pos, lineNr };\r\n        });\r\n    \r\n        return (await Promise.all(promises)).filter(f => !!f) as any;\r\n    }\r\n\r\n    protected getStartNewOrchestrationRegex(orchName: string): RegExp {\r\n        return new RegExp(`(Start-DurableOrchestration|Start-NewOrchestration).*-FunctionName\\\\s*[\"']${orchName}[\"']`, 'i');\r\n    }\r\n\r\n    protected getCallActivityRegex(activityName: string): RegExp {\r\n        return new RegExp(`(Invoke-DurableActivity|Invoke-ActivityFunction).*-FunctionName\\\\s*[\"']${activityName}[\"']`, 'i');\r\n    }\r\n\r\n    protected getRaiseEventRegex(eventName: string): RegExp {\r\n        return new RegExp(`Send-DurableExternalEvent.*-EventName\\\\s*[\"']${eventName}[\"']`, 'i');\r\n    }\r\n\r\n    protected getWaitForExternalEventRegex(): RegExAndPos {\r\n        return {\r\n            regex: new RegExp(`Start-DurableExternalEventListener.*-EventName\\\\s*[\"']([\\\\s\\\\w\\\\.-]+)[\"']`, 'gi'),\r\n            pos: 1\r\n        };\r\n    }\r\n}\r\n","import { FunctionsMap } from \"./FunctionsMap\";\r\nimport { getCodeInBrackets, posToLineNr } from \"./traverseFunctionProjectUtils\";\r\n\r\nimport { RegExAndPos } from \"./fileSystemWrapperBase\";\r\nimport { FunctionProjectCodeParser } from \"./functionProjectCodeParser\";\r\n\r\nexport class PythonV2FunctionProjectParser extends FunctionProjectCodeParser {\r\n\r\n    protected async getFunctionsAndTheirCodesAsync(functionNames: string[], hostJsonFolder: string): Promise<{ name: string; code: string; filePath: string; pos: number; lineNr: number; }[]> {\r\n\r\n        const promises = functionNames.map(async name => {\r\n\r\n            const match = await this._fileSystemWrapper.findFileRecursivelyAsync(hostJsonFolder, '.+\\\\.py$', true, this.getFunctionStartRegex(name));\r\n            \r\n            if (!match) {\r\n                return undefined;\r\n            }\r\n\r\n            const { declarationCode, bodyCode } = this.getFunctionCode(match.code!, match.pos!);\r\n\r\n            const pos = !match.pos ? 0 : match.pos;\r\n            const lineNr = posToLineNr(match.code, pos);\r\n\r\n            return { name, code: bodyCode, filePath: match.filePath, pos, lineNr };\r\n        });\r\n\r\n        return (await Promise.all(promises)).filter(f => !!f) as any;\r\n    }\r\n\r\n    protected async traverseProjectCode(projectFolder: string): Promise<FunctionsMap> {\r\n\r\n        const result: any = {};\r\n\r\n        for await (const func of this.findFunctionsRecursivelyAsync(projectFolder)) {\r\n            \r\n            const bindings = this.tryExtractBindings(func.declarationCode);\r\n    \r\n            result[func.functionName] = {\r\n\r\n                filePath: func.filePath,\r\n                pos: func.pos,\r\n                lineNr: func.lineNr,\r\n\r\n                bindings: [...bindings]\r\n            };\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    async * findFunctionsRecursivelyAsync(folder: string): AsyncGenerator<any> {\r\n\r\n        const fileNameRegex = new RegExp('.+\\\\.py$', 'i');\r\n        const functionAttributeRegex = this.getFunctionAttributeRegex();\r\n\r\n        const functionNameRegex = new RegExp(`\\\\.\\\\s*function_name\\\\s*\\\\(\\\\s*name\\\\s*=\\\\s*[\"']([\\\\w-]+)[\"']`);\r\n        \r\n        for await (const fullPath of this._fileSystemWrapper.findFilesRecursivelyAsync(folder, fileNameRegex)) {\r\n\r\n            const code = await this._fileSystemWrapper.readFile(fullPath);\r\n\r\n            let match: RegExpExecArray | null;\r\n            while (!!(match = functionAttributeRegex.regex.exec(code))) {\r\n\r\n                let functionName = match[functionAttributeRegex.pos];\r\n\r\n                let { declarationCode, bodyCode } = this.getFunctionCode(code, match.index);\r\n\r\n                const functionNameMatch = functionNameRegex.exec(declarationCode);\r\n                if (!!functionNameMatch) {\r\n                 \r\n                    functionName = functionNameMatch[1];\r\n\r\n                    // Need to remove this line so that it does not appear as binding\r\n                    declarationCode = declarationCode.replace('function_name', '');\r\n                }\r\n\r\n                yield {\r\n                    functionName,\r\n                    filePath: fullPath,\r\n                    pos: match.index,\r\n                    lineNr: posToLineNr(code, match.index),\r\n\r\n                    declarationCode,\r\n                    bodyCode\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    private getFunctionCode(code: string, endPos: number): { declarationCode: string, bodyCode: string } {\r\n\r\n        let declarationCode = '';\r\n        let bodyCode = '';\r\n\r\n        const defRegex = new RegExp('^(async)?\\\\s*def ', 'gm');\r\n        const nextMethodRegex = new RegExp('^[^\\\\s]', 'gm');\r\n\r\n        defRegex.lastIndex = endPos;\r\n        const defMatch = defRegex.exec(code);\r\n        if (!!defMatch) {\r\n            \r\n            declarationCode = code.substring(endPos, defMatch.index);\r\n\r\n            endPos = defMatch.index + defMatch[0].length;\r\n\r\n            nextMethodRegex.lastIndex = endPos;\r\n            const nextMethodMatch = nextMethodRegex.exec(code);\r\n            if (!!nextMethodMatch) {\r\n\r\n                bodyCode = code.substring(endPos, nextMethodMatch.index);\r\n                \r\n            } else {\r\n\r\n                bodyCode = code.substring(endPos);\r\n            }\r\n\r\n        } else {\r\n\r\n            declarationCode = code.substring(endPos);\r\n            bodyCode = code.substring(endPos);\r\n        }\r\n\r\n        return { declarationCode, bodyCode };\r\n    }\r\n\r\n    protected getFunctionAttributeRegex(): RegExAndPos {\r\n        return {\r\n            regex: new RegExp(`@[\\\\w\\\\s]+\\\\.\\\\s*(function_name|route|blob_trigger|cosmos_db_trigger|event_hub_message_trigger|queue_trigger|service_bus_queue_trigger|service_bus_topic_trigger|orchestration_trigger|activity_trigger|schedule)(.|\\r|\\n)+?def\\\\s+([\\\\w-]+)`, 'g'),\r\n            pos: 3\r\n        };\r\n    }\r\n\r\n    protected getFunctionStartRegex(funcName: string): RegExp {\r\n        return new RegExp(`(@[\\\\w\\\\s]+\\\\.\\\\s*function_name\\\\s*\\\\(\\\\s*name\\\\s*=\\\\s*[\"']${funcName}[\"']|^(async)?\\\\s*def\\\\s+${funcName})`, 'm')\r\n    }\r\n\r\n    protected getBindingAttributeRegex(): RegExAndPos {\r\n        \r\n        return {\r\n            regex: new RegExp(`@[\\\\w\\\\s]+\\\\.\\\\s*(\\\\w+)\\\\s*\\\\(`, 'g'),\r\n            pos: 1\r\n        };\r\n    }\r\n\r\n    protected getStartNewOrchestrationRegex(orchName: string): RegExp {\r\n        \r\n        return new RegExp(`\\\\.\\\\s*start_new\\\\s*\\\\(\\\\s*[\"']${orchName}[\"']`);\r\n    }\r\n}","\r\nexport function cleanupFunctionName(name: string): string {\r\n\r\n    if (!name) {\r\n        return name;\r\n    }\r\n\r\n    const nameofMatch = new RegExp(`nameof\\\\s*\\\\(\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\)`).exec(name);\r\n    if (!!nameofMatch) {\r\n\r\n        return removeNamespace(nameofMatch[1]);\r\n    }\r\n\r\n    name = name.trim();\r\n\r\n    if (name.startsWith('\"')) {\r\n        return name.replace(/^\"/, '').replace(/\"$/, '');\r\n    }\r\n\r\n    return removeNamespace(name);\r\n}\r\n\r\nexport function removeNamespace(name: string): string {\r\n\r\n    if (!name) {\r\n        return name;\r\n    }\r\n\r\n    const dotPos = name.lastIndexOf('.');\r\n    if (dotPos >= 0) {\r\n        name = name.substring(dotPos + 1);\r\n    }\r\n\r\n    return name.trim();\r\n}\r\n\r\n// Primitive way of getting a line number out of symbol position\r\nexport function posToLineNr(code: string | undefined, pos: number): number {\r\n    if (!code) {\r\n        return 0;\r\n    }\r\n    const lineBreaks = code.substr(0, pos).match(/(\\r\\n|\\r|\\n)/g);\r\n    return !lineBreaks ? 1 : lineBreaks.length + 1;\r\n}\r\n\r\n// Complements regex's inability to keep up with nested brackets\r\nexport function getCodeInBrackets(str: string, startFrom: number, openingBracket: string, closingBracket: string, mustHaveSymbols: string = ''): { code: string, openBracketPos: number } {\r\n\r\n    var bracketCount = 0, openBracketPos = -1, mustHaveSymbolFound = !mustHaveSymbols;\r\n\r\n    for (var i = startFrom; i < str.length; i++) {\r\n\r\n        switch (str[i]) {\r\n            case openingBracket:\r\n\r\n                if (bracketCount <= 0) {\r\n                    openBracketPos = i;\r\n                }\r\n                bracketCount++;\r\n\r\n                break;\r\n            case closingBracket:\r\n\r\n                bracketCount--;\r\n                if (bracketCount <= 0 && mustHaveSymbolFound) {\r\n                    return { code: str.substring(startFrom, i + 1), openBracketPos: openBracketPos - startFrom };\r\n                }\r\n                \r\n                break;\r\n        }\r\n\r\n        if (bracketCount > 0 && mustHaveSymbols.includes(str[i])) {\r\n            mustHaveSymbolFound = true;\r\n        }\r\n    }\r\n    return { code: '', openBracketPos: -1 };\r\n}\r\n\r\n// Complements regex's inability to keep up with nested brackets\r\nexport function getCodeInBracketsReverse(str: string, openingBracket: string, closingBracket: string): { code: string, openBracketPos: number } {\r\n\r\n    var bracketCount = 0, closingBracketPos = 0;\r\n    \r\n    for (var i = str.length - 1; i >= 0; i--) {\r\n\r\n        switch (str[i]) {\r\n            case closingBracket:\r\n\r\n                if (bracketCount <= 0) {\r\n                    closingBracketPos = i;\r\n                }\r\n                bracketCount++;\r\n\r\n                break;\r\n            case openingBracket:\r\n\r\n                bracketCount--;\r\n                if (bracketCount <= 0 ) {\r\n                    return { code: str.substring(0, closingBracketPos + 1), openBracketPos: i };\r\n                }\r\n                \r\n                break;\r\n        }\r\n    }\r\n    return { code: '', openBracketPos: -1 };\r\n}\r\n","module.exports = require(\"vscode\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import * as vscode from 'vscode';\r\n\r\nimport { FileSystemWrapper } from './FileSystemWrapper';\r\nimport { FunctionGraphView } from './FunctionGraphView';\r\n\r\nlet graphViews: FunctionGraphView[] = [];\r\n\r\nconst fsWrapper = new FileSystemWrapper();\r\n\r\nconst MaxProjectsToShowAutomatically = 5;\r\n\r\nasync function showAllFunctionProjects(context: vscode.ExtensionContext) {\r\n\r\n\tif (!vscode.workspace.workspaceFolders) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst hostJsonFolders = [];\r\n\r\n\ttry{\r\n\r\n\t\tfor (const folder of vscode.workspace.workspaceFolders) {\r\n\r\n\t\t\tfor await (const hostJsonPath of fsWrapper.findFilesRecursivelyAsync(folder.uri.toString(), new RegExp('host.json', 'i'))) {\r\n\t\t\t\t\r\n\t\t\t\thostJsonFolders.push(fsWrapper.dirName(hostJsonPath));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (hostJsonFolders.length > MaxProjectsToShowAutomatically) {\r\n\t\t\t\r\n\t\t\tconst userResponse = await vscode.window.showWarningMessage(\r\n\t\t\t\t`az-func-as-a-graph found ${hostJsonFolders.length} Azure Functions projects in current workspace. Do you want to visualize all of them?`,\r\n\t\t\t\t'Yes', 'No');\r\n\r\n\t\t\tif (userResponse !== 'Yes') {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t} catch (err: any) {\r\n\t\t\r\n\t\tvscode.window.showErrorMessage(`az-func-as-a-graph failed. ${err.message ?? err}`);\r\n\t}\r\n\r\n\tfor (const hostJsonFolder of hostJsonFolders) {\r\n\t\t\r\n\t\tgraphViews.push(new FunctionGraphView(context, vscode.Uri.parse(hostJsonFolder)));\r\n\t}\r\n}\r\n\r\nexport async function activate(context: vscode.ExtensionContext) {\r\n\r\n\tcontext.subscriptions.push(\r\n\r\n\t\tvscode.commands.registerCommand('az-func-as-a-graph.ShowGraph', async (item?: vscode.Uri) => {\r\n\r\n\t\t\tif (!!item) {\r\n\t\t\t\t\r\n\t\t\t\tconst pathToHostJson = item.toString();\r\n\r\n\t\t\t\tif (pathToHostJson.toLowerCase().endsWith('host.json')) {\r\n\t\t\t\t\t\r\n\t\t\t\t\tgraphViews.push(new FunctionGraphView(context, vscode.Uri.parse(fsWrapper.dirName(pathToHostJson))));\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tawait showAllFunctionProjects(context);\r\n\t\t})\t\t\r\n\t);\r\n\r\n\tif (!vscode.workspace.workspaceFolders) {\r\n\t\treturn;\r\n\t}\r\n\r\n    const config = vscode.workspace.getConfiguration('az-func-as-a-graph');\r\n\r\n\tif (!!config.get<boolean>('showGraphAtStartup', true)) {\r\n\r\n\t\t// Showing graphs of all Functions in the workspace\r\n\t\tawait showAllFunctionProjects(context);\r\n\t}\r\n}\r\n\r\n// This method is called when your extension is deactivated\r\nexport function deactivate() {\r\n\r\n\tfor (const view of graphViews) {\r\n\t\t\r\n\t\tview.cleanup();\r\n\t}\r\n}"],"names":["FileSystemWrapper","FileSystemWrapperBase","joinPath","path1","path2","vscode","Uri","parse","toString","dirName","i","lastIndexOf","Error","substring","readFile","path","uri","bytes","workspace","fs","TextDecoder","decode","isDirectory","stat","type","FileType","Directory","readDir","readDirectory","map","f","pathExists","File","err","FunctionGraphView","constructor","_context","_functionProjectUri","_webViewPanel","this","_staticsFolder","extensionUri","showWebView","cleanup","dispose","title","fsPath","panel","window","createWebviewPanel","viewType","ViewColumn","One","retainContextWhenHidden","enableScripts","localResourceRoots","fileUri","then","htmlBytes","html","fixLinksToStatics","webview","embedTheme","showErrorMessage","message","onDidReceiveMessage","request","handleMessageFromWebView","undefined","subscriptions","includes","activeColorTheme","kind","replace","webView","showInformationMessage","data","looksLikeSvg","showSaveDialog","defaultUri","file","filters","filePath","TextEncoder","encode","writeFile","_traversalResult","JSON","stringify","functionName","functionOrProxy","startsWith","proxies","substr","functions","showTextDocument","ed","pos","document","positionAt","selection","Selection","revealRange","Range","FunctionProjectParser","parseFunctions","console","log","res","Object","keys","length","postMessage","catch","originalHtml","staticsFolder","resultHtml","regex","match","exec","relativePath","localPath","newPath","asWebviewUri","endsWith","toLowerCase","CSharpFunctionProjectParser","FunctionProjectCodeParser","getFunctionsAndTheirCodesAsync","functionNames","hostJsonFolder","promises","async","name","_fileSystemWrapper","findFileRecursivelyAsync","getFunctionStartRegex","lineNr","posToLineNr","code","getCodeInBrackets","Promise","all","filter","traverseProjectCode","projectFolder","result","fileNameRegex","RegExp","func","findFunctionsRecursivelyAsync","getFunctionAttributeRegex","bindings","tryExtractBindings","declarationCode","some","b","push","extractOutputBindings","functionCode","returnTypeMatch","functionReturnTypeRegex","returnTypeName","removeNamespace","returnTypeDefinition","getClassDefinitionRegex","classBody","FSharpFunctionProjectParser","ExcludedFolders","readFunctionsJson","fullPath","functionJsonFilePath","functionJsonExists","functionJsonString","functionJson","isCalledBy","isSignalledBy","readProxiesJson","proxiesJsonPath","proxiesJsonString","notAddedToCsProjFile","isCSharpProjectAsync","csProjFile","proxiesJsonEntryRegex","proxyName","proxy","warningNotAddedToCsProjFile","index","fn","isFSharpProjectAsync","isJavaProjectAsync","isPowershellProjectAsync","firstFunctionJsonFile","isPythonV2ProjectAsync","pyFileMatch","functionJsonFileMatch","folder","fileName","returnFileContents","pattern","subFolders","subFolder","findFilesRecursivelyAsync","functionAttributeRegex","cleanupFunctionName","functionAttributeEndPos","body","openBracketPos","bodyCode","FunctionProjectParserBase","traverseFunctions","mapOrchestratorsAndActivitiesAsync","funcName","fileSystemWrapper","hostJsonMatch","parser","JavaFunctionProjectParser","PowershellFunctionProjectParser","PythonV2FunctionProjectParser","FunctionProjectScriptParser","_log","singleParamRegex","eventHubParamsRegex","signalRParamsRegex","rabbitMqParamsRegex","blobParamsRegex","cosmosDbParamsRegex","signalRConnInfoParamsRegex","eventGridParamsRegex","isOutRegex","httpMethods","httpTriggerRouteRegex","orchestratorNames","orchestrators","activityNames","activities","entityNames","entities","otherFunctionNames","otherFunctions","orch","getStartNewOrchestrationRegex","subOrch","getCallSubOrchestratorRegex","mapActivitiesToOrchestrator","getContinueAsNewRegex","isCalledByItself","eventNames","getEventNames","eventName","getRaiseEventRegex","signalName","entity","getSignalEntityRegex","concat","orchestratorCode","getWaitForExternalEventRegex","activityName","getCallActivityRegex","funcCode","getBindingAttributeRegex","isReturn","attributeName","attributeCodeStartIndex","attributeCode","lastIndex","isOut","binding","direction","paramsMatch","tableName","databaseName","collectionName","topicEndpointUri","topicKeySetting","eventHubName","brokerList","hubName","methods","httpTriggerRouteMatch","route","lowerAttributeCode","httpMethod","authLevel","orchName","subOrchName","entityName","className","scriptFile","functionJsonMatch","getFunctionCode","functionNameRegex","functionNameMatch","endPos","defRegex","nextMethodRegex","defMatch","nextMethodMatch","dotPos","trim","nameofMatch","lineBreaks","str","startFrom","openingBracket","closingBracket","mustHaveSymbols","bracketCount","mustHaveSymbolFound","closingBracketPos","module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","graphViews","fsWrapper","showAllFunctionProjects","context","workspaceFolders","hostJsonFolders","hostJsonPath","showWarningMessage","commands","registerCommand","item","pathToHostJson","getConfiguration","get","view"],"sourceRoot":""}